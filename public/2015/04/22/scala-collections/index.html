<!DOCTYPE html>













<html class="theme-next mist" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.css">
















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






  

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.2',
    sidebar: {"position":"left","display":"remove","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Scala有一个非常通用，丰富，强大，可组合的集合库，本文主要是整理Scala集合相关知识点。">
<meta name="keywords" content="scala">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala集合">
<meta property="og:url" content="http://javachen.github.io/2015/04/22/scala-collections/index.html">
<meta property="og:site_name" content="JavaChen Blog">
<meta property="og:description" content="Scala有一个非常通用，丰富，强大，可组合的集合库，本文主要是整理Scala集合相关知识点。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://javachen.github.io/static/images/images/scala.collection.png">
<meta property="og:image" content="http://javachen.github.io/images/scala.collection.immutable.jpg">
<meta property="og:image" content="http://javachen.github.io/images/scala.collection.mutable.png">
<meta property="og:updated_time" content="2019-06-29T12:34:25.724Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Scala集合">
<meta name="twitter:description" content="Scala有一个非常通用，丰富，强大，可组合的集合库，本文主要是整理Scala集合相关知识点。">
<meta name="twitter:image" content="http://javachen.github.io/static/images/images/scala.collection.png">



  <link rel="alternate" href="/atom.xml" title="JavaChen Blog" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://javachen.github.io/2015/04/22/scala-collections/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Scala集合 | JavaChen Blog</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?50bc6f5d9b045b5895ff44f8bbdbc611";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JavaChen Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">Ramblings of a coder</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://javachen.github.io/2015/04/22/scala-collections/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JavaChen">
      <meta itemprop="description" content="Rumblings by a coder on Java、Hadoop and so on">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JavaChen Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Scala集合<a href="https://github.com/javachen/javachen-blog-theme/tree/master/source/_posts/2015/2015-04-22-scala-collections.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil"></i></a>

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2015-04-22 00:00:00" itemprop="dateCreated datePublished" datetime="2015-04-22T00:00:00+08:00">2015-04-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-29 20:34:25" itemprop="dateModified" datetime="2019-06-29T20:34:25+08:00">2019-06-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/scala/" itemprop="url" rel="index"><span itemprop="name">scala</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <!--/删除
          
              <div class="post-description">
                  Scala有一个非常通用，丰富，强大，可组合的集合库，本文主要是整理Scala集合相关知识点。
              </div>
          
          -->

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>Scala有一个非常通用，丰富，强大，可组合的集合库；集合是高阶的(high level)并暴露了一大套操作方法。很多集合的处理和转换可以被表达的简洁又可读，但不审慎地用它们的功能也会导致相反的结果。每个Scala程序员应该阅读 集合设计文档；通过它可以很好地洞察集合库，并了解设计动机。</p>
<p>scala集合API：<a href="http://www.scala-lang.org/docu/files/collections-api/collections.html" target="_blank" rel="noopener">http://www.scala-lang.org/docu/files/collections-api/collections.html</a>。</p>
<p>怎样使用集合，请参考 <a href="http://twitter.github.io/effectivescala/index-cn.html#集合" target="_blank" rel="noopener">Effective Scala</a>。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>Scala的所有的集合类都可以在包 <code>scala.collection</code> 包中找到，其中的集合类都是高级抽象类或特性。</p>
<p><img src="/static/images/images/scala.collection.png" alt></p>
<p>Scala 集合类系统地区分了可变的和不可变的集合。可变集合可以在适当的地方被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素。而不可变集合类，相比之下，永远不会改变。不过，你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，同时使原来的集合不发生改变。</p>
<p>可变的集合类位于 <code>scala.collection.mutable</code> 包中，而不可变的集合位于 <code>scala.collection.immutable</code> 。<code>scala.collection</code> 包中的集合，既可以是可变的，也可以是不可变的。例如：<a href="http://www.scala-lang.org/api/current/scala/collection/IndexedSeq.html" target="_blank" rel="noopener">collection.IndexedSeq[T]</a> 就是 <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/IndexedSeq.html" target="_blank" rel="noopener">collection.immutable.IndexedSeq[T]</a> 和 <a href="http://www.scala-lang.org/api/current/scala/collection/mutable/IndexedSeq.html" target="_blank" rel="noopener">collection.mutable.IndexedSeq[T]</a> 这两类的超类。<code>scala.collection</code> 包中的根集合类中定义了相同的接口作为不可变集合类，同时，<code>scala.collection.mutable</code> 包中的可变集合类代表性的添加了一些有辅助作用的修改操作到这个 immutable 接口。</p>
<p>下面的图表显示 <code>scala.collection.immutable</code> 中的所有集合类。</p>
<p><img src="/images/scala.collection.immutable.jpg" alt></p>
<p>下面的图表显示 <code>scala.collection.mutable</code> 中的所有集合类。</p>
<p><img src="/images/scala.collection.mutable.png" alt></p>
<p><code>默认情况下，Scala 一直采用不可变集合类</code>。例如，如果你仅写了 <code>Set</code> 而没有任何加前缀也没有从其它地方导入 <code>Set</code>，你会得到一个不可变的 set，另外如果你写迭代，你也会得到一个不可变的迭代集合类，这是由于这些类在从 scala 中导入的时候都是默认绑定的。为了得到可变的默认版本，你需要显式的声明<code>collection.mutable.Set</code>或<code>collection.mutable.Iterable</code>。</p>
<p>一个有用的约定，如果你想要同时使用可变和不可变集合类，只导入 <code>collection.mutable</code> 包即可。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable  <span class="comment">//导入包scala.collection.mutable</span></span><br></pre></td></tr></table></figure>

<p>然而，像没有前缀的 <code>Set</code> 这样的关键字， 仍然指的是一个不可变集合，然而 <code>mutable.Set</code> 指的是可变的副本（可变集合）。</p>
<p>为了方便和向后兼容性，一些导入类型在包 scala 中有别名，所以你能通过简单的名字使用它们而不需要 import。这有一个例子是 <code>List</code>类型，它可以用以下两种方法使用，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala.collection.immutable.<span class="type">List</span> <span class="comment">// 这是它的定义位置</span></span><br><span class="line">scala.<span class="type">List</span> <span class="comment">//通过scala 包中的别名</span></span><br><span class="line"><span class="type">List</span> <span class="comment">// 因为scala._ 总是是被自动导入。</span></span><br></pre></td></tr></table></figure>

<p>其它类型的别名有： Traversable, Iterable, Seq, IndexedSeq, Iterator, Stream, Vector, StringBuilder, Range。</p>
<table>
<thead>
<tr>
<th align="left">不可变（collection.immutable._）</th>
<th align="left">可变（collection.mutable._）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Array</td>
<td align="left">ArrayBuffer</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">ListBuffer</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">StringBuilder</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">LinkedList, DoubleLinkedList</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">MutableList</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">Queue</td>
</tr>
<tr>
<td align="left">Array</td>
<td align="left">ArraySeq</td>
</tr>
<tr>
<td align="left">Stack</td>
<td align="left">ArrayStack</td>
</tr>
<tr>
<td align="left">HashMap HashSet</td>
<td align="left">HashMap HashSet</td>
</tr>
</tbody></table>
<h1 id="Traversable"><a href="#Traversable" class="headerlink" title="Traversable"></a>Traversable</h1><p>Traversable 是容器类的最高级别特性，它唯一的抽象操作是 foreach：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">U</span>](f: <span class="type">Elem</span> =&gt; <span class="type">U</span>)</span><br></pre></td></tr></table></figure>

<p>Traversable 同时定义的很多具体方法：</p>
<ul>
<li>相加操作++</li>
<li>Map 操作有 map，flatMap 和 collect<ul>
<li><code>xs map f</code>  通过函数xs中的每一个元素调用函数f来生成一个容器。</li>
<li><code>xs flatMap f</code>  通过对容器xs中的每一个元素调用作为容器的值函数f，在把所得的结果连接起来作为一个新的容器。</li>
<li><code>xs collect f</code>  通过对每个xs中的符合定义的元素调用偏函数f，并把结果收集起来生成一个集合。</li>
</ul>
</li>
<li>转换操作包括 toArray，toList，toIterable，toSeq，toIndexedSeq，toStream，toSet，和 toMap<ul>
<li><code>xs.toArray</code>  把容器转换为一个数组</li>
<li><code>xs.toList</code> 把容器转换为一个list</li>
<li><code>xs.toIterable</code> 把容器转换为一个迭代器。</li>
<li><code>xs.toSeq</code>  把容器转换为一个序列</li>
<li><code>xs.toIndexedSeq</code> 把容器转换为一个索引序列</li>
<li><code>xs.toStream</code> 把容器转换为一个延迟计算的流。</li>
<li><code>xs.toSet</code>  把容器转换为一个Set。</li>
<li><code>xs.toMap</code>  把由键/值对组成的容器转换为一个映射表。如果该容器并不是以键/值对作为元素的，那么调用这个操作将会导致一个静态类型的错误。 </li>
</ul>
</li>
<li>拷贝操作有 copyToBuffer 和 copyToArray<ul>
<li><code>xs copyToBuffer buf</code> 把容器的所有元素拷贝到buf缓冲区。</li>
<li><code>xs copyToArray(arr, s, n)</code> 拷贝最多n个元素到数组arr的坐标s处。参数s，n是可选项。 </li>
</ul>
</li>
<li>Size 操作包括有 isEmpty，nonEmpty，size 和 hasDefiniteSize<ul>
<li><code>xs.isEmpty</code>  测试容器是否为空。</li>
<li><code>xs.nonEmpty</code> 测试容器是否包含元素。</li>
<li><code>xs.size</code> 计算容器内元素的个数。</li>
<li><code>xs.hasDefiniteSize</code>  如果xs的大小是有限的，则为true。 </li>
</ul>
</li>
<li>元素检索操作有 head，last，headOption，lastOption 和 find<ul>
<li><code>xs.head</code> 返回容器内第一个元素（或其他元素，若当前的容器无序）。</li>
<li><code>xs.headOption</code> xs选项值中的第一个元素，若xs为空则为None。</li>
<li><code>xs.last</code> 返回容器的最后一个元素（或某个元素，如果当前的容器无序的话）。</li>
<li><code>xs.lastOption</code> xs选项值中的最后一个元素，如果xs为空则为None。</li>
<li><code>xs find p</code> 查找xs中满足p条件的元素，若存在则返回第一个元素；若不存在，则为空。</li>
</ul>
</li>
<li>子容器检索操作有 tail，init，slice，take，drop，takeWhilte，dropWhile，filter，filteNot 和 withFilter<ul>
<li><code>xs.tail</code> 返回由除了xs.head外的其余部分。</li>
<li><code>xs.init</code> 返回除xs.last外的其余部分。</li>
<li><code>xs slice (from, to)</code> 返回由xs的一个片段索引中的元素组成的容器（从from到to，但不包括to）。</li>
<li><code>xs take n</code> 由xs的第一个到第n个元素（或当xs无序时任意的n个元素）组成的容器。</li>
<li><code>xs drop n</code> 由除了xs take n以外的元素组成的容器。</li>
<li><code>xs takeWhile p</code>  容器xs中最长能够满足断言p的前缀。</li>
<li><code>xs dropWhile p</code>  容器xs中除了xs takeWhile p以外的全部元素。</li>
<li><code>xs filter p</code> 由xs中满足条件p的元素组成的容器。</li>
<li><code>xs withFilter p</code> 这个容器是一个不太严格的过滤器。子容器调用map，flatMap，foreach和withFilter只适用于xs中那些的满足条件p的元素。</li>
<li><code>xs filterNot p</code>  由xs中不满足条件p的元素组成的容器。</li>
</ul>
</li>
<li>拆分操作有 splitAt，span，partition 和 groupBy<ul>
<li><code>xs splitAt n</code>  把xs从指定位置的拆分成两个容器（<code>xs take n</code>和<code>xs drop n</code>）。</li>
<li><code>xs span p</code> 根据一个断言p将xs拆分为两个容器（<code>xs takeWhile p</code>, <code>xs.dropWhile p</code>）。</li>
<li><code>xs partition p</code>  把xs分割为两个容器，符合断言p的元素赋给一个容器，其余的赋给另一个(<code>xs filter p</code>, <code>xs.filterNot p</code>)。</li>
<li><code>xs groupBy f</code>  根据判别函数f把xs拆分一个到容器的map中。</li>
</ul>
</li>
<li>元素测试包括有 exists，forall 和 count<ul>
<li><code>xs forall p</code> 返回一个布尔值表示用于表示断言p是否适用xs中的所有元素。</li>
<li><code>xs exists p</code> 返回一个布尔值判断xs中是否有部分元素满足断言p。</li>
<li><code>xs count p</code>  返回xs中符合断言p条件的元素个数。</li>
</ul>
</li>
<li>折叠操作有 foldLeft，foldRight，/:，:\，reduceLeft 和 reduceRight<ul>
<li><code>(z /: xs)(op)</code> 在xs中，对由z开始从左到右的连续元素应用二进制运算op。</li>
<li><code>(xs :\ z)(op)</code> 在xs中，对由z开始从右到左的连续元素应用二进制运算op</li>
<li><code>xs.foldLeft(z)(op)</code> 与 <code>(z /: xs)(op)</code>相同。</li>
<li><code>xs.foldRight(z)(op)</code> 与 <code>(xs :\ z)(op)</code>相同。</li>
<li><code>xs reduceLeft op</code>  非空容器xs中的连续元素从左至右调用二进制运算op。</li>
<li><code>xs reduceRight op</code> 非空容器xs中的连续元素从右至左调用二进制运算op。</li>
</ul>
</li>
<li>特殊折叠包括 sum, product, min, max<ul>
<li><code>xs.sum</code>  返回容器xs中数字元素的和。</li>
<li><code>xs.product</code>  xs返回容器xs中数字元素的积。</li>
<li><code>xs.min</code>  容器xs中有序元素值中的最小值。</li>
<li><code>xs.max</code>  容器xs中有序元素值中的最大值。</li>
</ul>
</li>
<li>字符串操作有 mkString，addString 和 stringPrefix<ul>
<li><code>xs addString (b, start, sep, end)</code> 把一个字符串加到StringBuilder对象b中，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。</li>
<li><code>xs mkString (start, sep, end)</code> 把容器xs转换为一个字符串，该字符串显示为将xs中所有元素用分隔符sep连接起来并封装在start和end之间。其中start，end和sep都是可选的。</li>
<li><code>xs.stringPrefix</code> 返回一个字符串，该字符串是以容器名开头的 xs.toString。</li>
</ul>
</li>
<li>视图操作包含两个view方法的重载体<ul>
<li><code>xs.view</code> 通过容器xs生成一个视图。</li>
<li><code>xs view (from, to)</code>  生成一个表示在指定索引范围内的xs元素的视图。</li>
</ul>
</li>
</ul>
<h1 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h1><p>继承 Traversable 的特性是 Iterable，该类实现了 foreach 方法，定义了一个迭代器。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">U</span>](f: <span class="type">Elem</span> =&gt; <span class="type">U</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> it = iterator</span><br><span class="line">  <span class="keyword">while</span> (it.hasNext) f(it.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterable 有两个方法返回迭代器：grouped 和 sliding。grouped 方法返回元素的增量分块，sliding 方法生成一个滑动元素的窗口。两者的差异见下面代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> xs = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">xs: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> git = xs grouped <span class="number">3</span></span><br><span class="line">git: <span class="type">Iterator</span>[<span class="type">List</span>[<span class="type">Int</span>]] = non-empty iterator</span><br><span class="line">scala&gt; git.next()</span><br><span class="line">res3: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">scala&gt; git.next()</span><br><span class="line">res4: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> sit = xs sliding <span class="number">3</span></span><br><span class="line">sit: <span class="type">Iterator</span>[<span class="type">List</span>[<span class="type">Int</span>]] = non-empty iterator</span><br><span class="line">scala&gt; sit.next()</span><br><span class="line">res5: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">scala&gt; sit.next()</span><br><span class="line">res6: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">scala&gt; sit.next()</span><br><span class="line">res7: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>Iterable 增加了一些其他方法：</p>
<ul>
<li><code>xs takeRight n</code>  一个容器由xs的最后n个元素组成（若定义的元素是无序，则由任意的n个元素组成）。</li>
<li><code>xs dropRight n</code>  一个容器由除了xs 被取走的（执行过takeRight方法）n个元素外的其余元素组成。</li>
<li><code>xs zip ys</code> 把一对容器 xs和ys的包含的元素合成到一个iterabale。</li>
<li><code>xs zipAll (ys, x, y)</code>  一对容器 xs 和ys的相应的元素合并到一个iterable ，实现方式是通过附加的元素x或y，把短的序列被延展到相对更长的一个上。</li>
<li><code>xs.zip WithIndex</code>  把一对容器xs和它的序列，所包含的元素组成一个iterable 。</li>
<li><code>xs sameElements ys</code>  测试 xs 和 ys 是否以相同的顺序包含相同的元素。</li>
</ul>
<h1 id="Seq"><a href="#Seq" class="headerlink" title="Seq"></a>Seq</h1><p>序列，指的是一类具有一定长度的可迭代访问的对象，其中每个元素均带有一个从0开始计数的固定索引位置。</p>
<p>序列的操作有以下几种，如下表所示：</p>
<ul>
<li><p>索引和长度 </p>
<ul>
<li><code>xs(i)</code> (或者为<code>xs apply i</code>)。xs的第i个元素</li>
<li><code>xs isDefinedAt i</code>  测试xs.indices中是否包含i。</li>
<li><code>xs.length</code> 序列的长度（同size）。</li>
<li><code>xs.lengthCompare ys</code> 如果xs的长度小于ys的长度，则返回-1。如果xs的长度大于ys的长度，则返回+1，如果它们长度相等，则返回0。即使其中一个序列是无限的，也可以使用此方法。</li>
<li><code>xs.indices</code>  xs的索引范围，从0到xs.length - 1。</li>
</ul>
</li>
<li><p>索引搜索  </p>
<ul>
<li><code>xs indexOf x</code>  返回序列xs中等于x的第一个元素的索引（存在多种变体）。</li>
<li><code>xs lastIndexOf x</code>  返回序列xs中等于x的最后一个元素的索引（存在多种变体）。</li>
<li><code>xs indexOfSlice ys</code>  查找子序列ys，返回xs中匹配的第一个索引。</li>
<li><code>xs indexOfSlice ys</code>  查找子序列ys，返回xs中匹配的倒数一个索引。</li>
<li><code>xs indexWhere p</code> xs序列中满足p的第一个元素。（有多种形式）</li>
<li><code>xs segmentLength (p, i)</code> xs中，从xs(i)开始并满足条件p的元素的最长连续片段的长度。</li>
<li><code>xs prefixLength p</code> xs序列中满足p条件的先头元素的最大个数。</li>
</ul>
</li>
<li><p>加法 </p>
<ul>
<li><code>x +: xs</code> 由序列xs的前方添加x所得的新序列。</li>
<li><code>xs :+ x</code> 由序列xs的后方追加x所得的新序列。</li>
<li><code>xs padTo (len, x)</code> 在xs后方追加x，直到长度达到len后得到的序列。</li>
</ul>
</li>
<li><p>更新  </p>
<ul>
<li><code>xs patch (i, ys, r)</code> 将xs中第i个元素开始的r个元素，替换为ys所得的序列。</li>
<li><code>xs updated (i, x)</code> 将xs中第i个元素替换为x后所得的xs的副本。</li>
<li><code>xs(i) = x</code> （或写作 <code>xs.update(i, x)</code>，仅适用于可变序列）将xs序列中第i个元素修改为x。</li>
</ul>
</li>
<li><p>排序  </p>
<ul>
<li><code>xs.sorted</code> 通过使用xs中元素类型的标准顺序，将xs元素进行排序后得到的新序列。</li>
<li><code>xs sortWith lt</code> 将lt作为比较操作，并以此将xs中的元素进行排序后得到的新序列。</li>
<li><code>xs sortBy f</code> 将序列xs的元素进行排序后得到的新序列。参与比较的两个元素各自经f函数映射后得到一个结果，通过比较它们的结果来进行排序。</li>
</ul>
</li>
<li><p>反转  </p>
<ul>
<li><code>xs.reverse</code>  与xs序列元素顺序相反的一个新序列。</li>
<li><code>xs.reverseIterator</code>  产生序列xs中元素的反序迭代器。</li>
<li><code>xs reverseMap f</code> 以xs的相反顺序，通过f映射xs序列中的元素得到的新序列。</li>
</ul>
</li>
<li><p>比较  </p>
<ul>
<li><code>xs startsWith ys</code>  测试序列xs是否以序列ys开头（存在多种形式）。</li>
<li><code>xs endsWith ys</code>  测试序列xs是否以序列ys结束（存在多种形式）。</li>
<li><code>xs contains x</code> 测试xs序列中是否存在一个与x相等的元素。</li>
<li><code>xs containsSlice ys</code> 测试xs序列中是否存在一个与ys相同的连续子序列。</li>
<li><code>(xs corresponds ys)(p)</code>  测试序列xs与序列ys中对应的元素是否满足二元的判断式p。</li>
</ul>
</li>
<li><p>多集操作  </p>
<ul>
<li><code>xs intersect ys</code> 序列xs和ys的交集，并保留序列xs中的顺序。</li>
<li><code>xs diff ys</code>  序列xs和ys的差集，并保留序列xs中的顺序。</li>
<li><code>xs union ys</code> 并集；同xs ++ ys。</li>
<li><code>xs.distinct</code>不含重复元素的xs的子序列。</li>
</ul>
<p>Seq 具有两个子特征 <a href="http://www.scala-lang.org/api/current/scala/collection/IndexedSeq.html" target="_blank" rel="noopener">LinearSeq</a> 和 <a href="http://www.scala-lang.org/api/current/scala/collection/IndexedSeq.html" target="_blank" rel="noopener">IndexedSeq</a>。它们不添加任何新的操作，但都提供不同的性能特点：线性序列具有高效的 head 和 tail 操作，而索引序列具有高效的apply, length, 和 (如果可变) update操作。</p>
</li>
</ul>
<h2 id="缓冲器"><a href="#缓冲器" class="headerlink" title="缓冲器"></a>缓冲器</h2><p><code>Buffers是可变序列一个重要的种类</code>。它们不仅允许更新现有的元素，而且允许元素的插入、移除和在buffer尾部高效地添加新元素。buffer 支持的主要新方法有：用于在尾部添加元素的 <code>+=</code> 和 <code>++=</code>；用于在前方添加元素的 <code>+=:</code> 和 <code>++=:</code>；用于插入元素的 insert 和 insertAll；以及用于删除元素的 remove 和 <code>-=</code>。</p>
<p>Buffer类的操作：</p>
<ul>
<li>加法<ul>
<li><code>buf += x</code> 将元素x追加到buffer，并将buf自身作为结果返回。</li>
<li><code>buf += (x, y, z)</code>  将给定的元素追加到buffer。</li>
<li><code>buf ++= xs</code>  将xs中的所有元素追加到buffer。</li>
<li><code>x +=: buf</code> 将元素x添加到buffer的前方。</li>
<li><code>xs ++=: buf</code> 将xs中的所有元素都添加到buffer的前方。</li>
<li><code>buf insert (i, x)</code> 将元素x插入到buffer中索引为i的位置。</li>
<li><code>buf insertAll (i, xs)</code> 将xs的所有元素都插入到buffer中索引为i的位置。</li>
</ul>
</li>
<li>移除<ul>
<li><code>buf -= x</code>  将元素x从buffer中移除。</li>
<li><code>buf remove i</code>  将buffer中索引为i的元素移除。</li>
<li><code>buf remove (i, n)</code> 将buffer中从索引i开始的n个元素移除。</li>
<li><code>buf trimStart n</code> 移除buffer中的前n个元素。</li>
<li><code>buf trimEnd n</code> 移除buffer中的后n个元素。</li>
<li><code>buf.clear()</code> 移除buffer中的所有元素。</li>
</ul>
</li>
<li>克隆 <ul>
<li><code>buf.clone</code> 与buf具有相同元素的新buffer。</li>
</ul>
</li>
</ul>
<p>ListBuffer 和 ArrayBuffer 是常用的 buffer 实现 。顾名思义，ListBuffe r依赖列表，支持高效地将它的元素转换成列表。而ArrayBuffer依赖数组，能快速地转换成数组。</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 是不包含重复元素的可迭代对象。</p>
<p>不可变 Set 类的操作：</p>
<ul>
<li>测试 <ul>
<li><code>xs contains x</code> 测试x是否是xs的元素。</li>
<li><code>xs(x)</code> 与<code>xs contains x</code>相同。</li>
<li><code>xs subsetOf ys</code>  测试xs是否是ys的子集。</li>
</ul>
</li>
<li>加法： <ul>
<li><code>xs + x</code>  包含xs中所有元素以及x的集合。</li>
<li><code>xs + (x, y, z)</code>  包含xs中所有元素及附加元素的集合</li>
<li><code>xs ++ ys</code>  包含xs中所有元素及ys中所有元素的集合</li>
</ul>
</li>
<li>减法： <ul>
<li><code>xs - x</code>  包含xs中除x以外的所有元素的集合。</li>
<li><code>xs - x</code>  包含xs中除去给定元素以外的所有元素的集合。</li>
<li><code>xs -- ys</code>  集合内容为：xs中所有元素，去掉ys中所有元素后剩下的部分。</li>
<li><code>xs.empty</code>  与xs同类的空集合。</li>
</ul>
</li>
<li>二进制操作：  <ul>
<li><code>xs &amp; ys</code> 集合xs和ys的交集。</li>
<li><code>xs intersect ys</code> 等同于 xs &amp; ys。</li>
<li><code>xs union ys</code> 等同于xs</li>
<li><code>xs &amp;~ ys</code>  集合xs和ys的差集。</li>
<li><code>xs diff ys</code>  等同于 <code>xs &amp;~ ys</code>。</li>
</ul>
</li>
</ul>
<p>可变 Set 类的操作</p>
<ul>
<li>加法： <ul>
<li><code>xs += x</code> 把元素x添加到集合xs中。该操作有副作用，它会返回左操作符，这里是xs自身。</li>
<li><code>xs += (x, y, z)</code> 添加指定的元素到集合xs中，并返回xs本身。（同样有副作用）</li>
<li><code>xs ++= ys</code> 添加集合ys中的所有元素到集合xs中，并返回xs本身。（表达式有副作用）</li>
<li><code>xs add x</code>  把元素x添加到集合xs中，如集合xs之前没有包含x，该操作返回true，否则返回false。</li>
</ul>
</li>
<li>移除： <ul>
<li><code>xs -= x</code> 从集合xs中删除元素x，并返回xs本身。（表达式有副作用）</li>
<li><code>xs -= (x, y, z)</code> 从集合xs中删除指定的元素，并返回xs本身。（表达式有副作用）</li>
<li><code>xs --= ys</code> 从集合xs中删除所有属于集合ys的元素，并返回xs本身。（表达式有副作用）</li>
<li><code>xs remove x</code> 从集合xs中删除元素x。如之前xs中包含了x元素，返回true，否则返回false。</li>
<li><code>xs retain p</code> 只保留集合xs中满足条件p的元素。</li>
<li><code>xs.clear()</code>  删除集合xs中的所有元素。</li>
</ul>
</li>
<li>更新：<ul>
<li><code>xs(x) = b</code> （ 同 <code>xs.update(x, b)</code> ）参数b为布尔类型，如果值为true就把元素x加入集合xs，否则从集合xs中删除x。</li>
</ul>
</li>
<li>克隆： <ul>
<li><code>xs.clone</code>  产生一个与xs具有相同元素的可变集合。</li>
</ul>
</li>
</ul>
<p>与不变集合一样，可变集合也提供了<code>+</code>和<code>++</code>操作符来添加元素，<code>-</code>和<code>--</code>用来删除元素。但是这些操作在可变集合中通常很少使用，因为这些操作都要通过集合的拷贝来实现。可变集合提供了更有效率的更新方法，<code>+=</code>和<code>-=</code>。</p>
<p><code>s += elem</code>，添加元素elem到集合s中，并返回产生变化后的集合作为运算结果。同样的，<code>s -= elem</code>执行从集合s中删除元素elem的操作，并返回产生变化后的集合作为运算结果。除了<code>+=</code>和<code>-=</code>之外还有从可遍历对象集合或迭代器集合中添加和删除所有元素的批量操作符<code>++=</code>和<code>--=</code>。</p>
<p>Set集合的两个特质是SortedSet和 BitSet。</p>
<h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><p>SortedSet 是指以特定的顺序（这一顺序可以在创建集合之初自由的选定）排列其元素（使用iterator或foreach）的集合。 SortedSet 的默认表示是有序二叉树，即左子树上的元素小于所有右子树上的元素。这样，一次简单的顺序遍历能按增序返回集合中的所有元素。Scala的类 <code>immutable.TreeSet</code> 使用红黑树实现，它在维护元素顺序的同时，也会保证二叉树的平衡，即叶节点的深度差最多为1。</p>
<p>创建一个空的 TreeSet ，可以先定义排序规则：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> myOrdering = <span class="type">Ordering</span>.fromLessThan[<span class="type">String</span>](_ &gt; _)</span><br><span class="line">myOrdering: scala.math.<span class="type">Ordering</span>[<span class="type">String</span>] = scala.math.<span class="type">Ordering</span>$$anon$<span class="number">9</span>@<span class="number">6</span>bd5a0fa</span><br></pre></td></tr></table></figure>

<p>然后，用这一排序规则创建一个空的树集：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">TreeSet</span>.empty(myOrdering)</span><br><span class="line">res1: scala.collection.immutable.<span class="type">TreeSet</span>[<span class="type">String</span>] = <span class="type">TreeSet</span>()</span><br></pre></td></tr></table></figure>

<p>或者，你也可以不指定排序规则参数，只需要给定一个元素类型或空集合。在这种情况下，将使用此元素类型默认的排序规则。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">TreeSet</span>.empty[<span class="type">String</span>]</span><br><span class="line">res2: scala.collection.immutable.<span class="type">TreeSet</span>[<span class="type">String</span>] = <span class="type">TreeSet</span>()</span><br></pre></td></tr></table></figure>

<p>如果通过已有的TreeSet来创建新的集合（例如，通过串联或过滤操作），这些集合将和原集合保持相同的排序规则。例如，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res2 + (<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line">res3: scala.collection.immutable.<span class="type">TreeSet</span>[<span class="type">String</span>] = <span class="type">TreeSet</span>(four, one, three, two)</span><br></pre></td></tr></table></figure>

<p>有序集合同样支持元素的范围操作。例如，range方法返回从指定起始位置到结束位置（不含结束元素）的所有元素，from方法返回大于等于某个元素的所有元素。调用这两种方法的返回值依然是有序集合。例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res3 range (<span class="string">"one"</span>, <span class="string">"two"</span>)</span><br><span class="line">res4: scala.collection.immutable.<span class="type">TreeSet</span>[<span class="type">String</span>] = <span class="type">TreeSet</span>(one, three)</span><br><span class="line">scala&gt; res3 from <span class="string">"three"</span></span><br><span class="line">res5: scala.collection.immutable.<span class="type">TreeSet</span>[<span class="type">String</span>] = <span class="type">TreeSet</span>(three, two)</span><br></pre></td></tr></table></figure>

<h2 id="Bitset"><a href="#Bitset" class="headerlink" title="Bitset"></a>Bitset</h2><p>位集合是由单字或多字的紧凑位实现的非负整数的集合。其内部使用Long型数组来表示。第一个Long元素表示的范围为0到63，第二个范围为64到127，以此类推（值为0到127的非可变位集合通过直接将值存储到第一个或第两个Long字段的方式，优化掉了数组处理的消耗）。对于每个Long，如果有相应的值包含于集合中则它对应的位设置为1，否则该位为0。这里遵循的规律是，位集合的大小取决于存储在该集合的最大整数的值的大小。假如N是为集合所要表示的最大整数，则集合的大小就是N/64个长整形字，或者N/8个字节，再加上少量额外的状态信息字节。</p>
<p>因此当位集合包含的元素值都比较小时，它比其他的集合类型更紧凑。位集合的另一个优点是它的contains方法（成员测试）、+=运算（添加元素）、-=运算（删除元素）都非常的高效。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bs = collection.mutable.<span class="type">BitSet</span>()</span><br><span class="line">bs += (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>) <span class="comment">// BitSet(1, 5, 3)</span></span><br><span class="line">bs ++= <span class="type">List</span>(<span class="number">7</span>,<span class="number">9</span>) <span class="comment">// BitSet(1, 9, 7, 5, 3)</span></span><br><span class="line">bs.clear <span class="comment">// BitSet()</span></span><br></pre></td></tr></table></figure>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map是一种可迭代的键值对结构（也称映射或关联）。Scala的Predef类提供了隐式转换，允许使用另一种语法：<code>key -&gt; value</code>，来代替<code>(key, value)</code>。如：<code>Map(&quot;x&quot; -&gt; 24, &quot;y&quot; -&gt; 25, &quot;z&quot; -&gt; 26)</code> 等同于 <code>Map((&quot;x&quot;, 24), (&quot;y&quot;, 25), (&quot;z&quot;, 26))</code>，却更易于阅读。</p>
<p>不可变Map类的操作:</p>
<ul>
<li>查询： <ul>
<li><code>ms get k</code>  返回一个Option，其中包含和键k关联的值。若k不存在，则返回None。</li>
<li><code>ms(k)</code> （完整写法是<code>ms apply k</code>）返回和键k关联的值。若k不存在，则抛出异常。</li>
<li><code>ms getOrElse (k, d)</code>返回和键k关联的值。若k不存在，则返回默认值d。</li>
<li><code>ms contains k</code> 检查ms是否包含与键k相关联的映射。</li>
<li><code>ms isDefinedAt k</code>  同contains。</li>
</ul>
</li>
<li>添加及更新:  <ul>
<li><code>ms + (k -&gt; v)</code> 返回一个同时包含ms中所有键值对及从k到v的键值对k -&gt; v的新映射。</li>
<li><code>ms + (k -&gt; v, l -&gt; w)</code> 返回一个同时包含ms中所有键值对及所有给定的键值对的新映射。</li>
<li><code>ms ++ kvs</code> 返回一个同时包含ms中所有键值对及kvs中的所有键值对的新映射。</li>
<li><code>ms updated (k, v)</code> 同<code>ms + (k -&gt; v)</code>。</li>
</ul>
</li>
<li>移除： <ul>
<li><code>ms - k</code>  返回一个包含ms中除键k以外的所有映射关系的映射。</li>
<li><code>ms - (k, 1, m)</code>  返回一个滤除了ms中与所有给定的键相关联的映射关系的新映射。</li>
<li><code>ms -- ks</code>  返回一个滤除了ms中与ks中给出的键相关联的映射关系的新映射。</li>
</ul>
</li>
<li>子容器： <ul>
<li><code>ms.keys</code> 返回一个用于包含ms中所有键的iterable对象</li>
<li><code>ms.keySet</code> 返回一个包含ms中所有的键的集合。</li>
<li><code>ms.keyIterator</code>  返回一个用于遍历ms中所有键的迭代器。</li>
<li><code>ms.values</code> 返回一个包含ms中所有值的iterable对象。</li>
<li><code>ms.valuesIterator</code> 返回一个用于遍历ms中所有值的迭代器。</li>
</ul>
</li>
<li>变换： <ul>
<li><code>ms filterKeys p</code> 一个映射视图，其包含一些ms中的映射，且这些映射的键满足条件p。用条件谓词p过滤ms中所有的键，返回一个仅包含与过滤出的键值对的映射视图。</li>
<li><code>ms mapValues f</code>  用f将ms中每一个键值对的值转换成一个新的值，进而返回一个包含所有新键值对的映射视图。</li>
</ul>
</li>
</ul>
<p>可变Map类中的操作：</p>
<ul>
<li><p>添加及更新：</p>
<ul>
<li><code>ms(k) = v</code> （完整形式为<code>ms.update(x, v)</code>）。向映射ms中新增一个以k为键、以v为值的映射关系，ms先前包含的以k为值的映射关系将被覆盖。</li>
<li><code>ms += (k -&gt; v)</code>  向映射ms增加一个以k为键、以v为值的映射关系，并返回ms自身。</li>
<li><code>ms += (k -&gt; v, l -&gt; w)</code> 向映射ms中增加给定的多个映射关系，并返回ms自身。</li>
<li><code>ms ++= kvs</code>  向映射ms增加kvs中的所有映射关系，并返回ms自身。</li>
<li><code>ms put (k, v)</code> 向映射ms增加一个以k为键、以v为值的映射，并返回一个Option，其中可能包含此前与k相关联的值。</li>
<li><code>ms getOrElseUpdate (k, d)</code> 如果ms中存在键k，则返回键k的值。否则向ms中新增映射关系<code>k -&gt; v</code>并返回d。</li>
</ul>
</li>
<li><p>移除： </p>
<ul>
<li><code>ms -= k</code> 从映射ms中删除以k为键的映射关系，并返回ms自身。</li>
<li><code>ms -= (k, l, m)</code> 从映射ms中删除与给定的各个键相关联的映射关系，并返回ms自身。</li>
<li><code>ms --= ks</code> 从映射ms中删除与ks给定的各个键相关联的映射关系，并返回ms自身。</li>
<li><code>ms remove k</code> 从ms中移除以k为键的映射关系，并返回一个Option，其可能包含之前与k相关联的值。</li>
<li><code>ms retain p</code> 仅保留ms中键满足条件谓词p的映射关系。</li>
<li><code>ms.clear()</code>  删除ms中的所有映射关系</li>
</ul>
</li>
<li><p>变换： </p>
<ul>
<li><code>ms transform f</code>  以函数f转换ms中所有键值对，transform中参数f的类型是<code>(A, B) =&gt; B</code>，即对ms中的所有键值对调用f，得到一个新的值，并用该值替换原键值对中的值。</li>
</ul>
</li>
<li><p>克隆： </p>
<ul>
<li><code>ms.clone</code>  返回一个新的可变映射，其中包含与ms相同的映射关系。</li>
</ul>
<p>Map的添加和删除操作与Set的相关操作相同。同Set操作一样，可变映射也支持非破坏性修改操作<code>+</code>、<code>-</code>、和 <code>updated</code>。但是这些操作涉及到可变映射的复制，因此较少被使用。而利用两种变形<code>m(key) = value</code>和<code>m += (key -&gt; value)</code>， 我们可以“原地”修改可变映射m。此外，存还有一种变形<code>m put (key, value)</code>，该调用返回一个Option值，其中包含此前与键相关联的值，如果不存在这样的值，则返回None。</p>
<p>同步的Map，使用SychronizedMap，同步Set，使用SynchronizedSet。</p>
</li>
</ul>
<p><code>不可变Map</code>的定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建map并指定类型</span></span><br><span class="line">scala&gt; <span class="keyword">var</span> m1 = <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</span><br><span class="line">m: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>()  <span class="comment">//缺醒是不可变map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建map并初始化</span></span><br><span class="line">scala&gt; <span class="keyword">var</span> m2 = <span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="number">100</span>, <span class="number">2</span>-&gt;<span class="number">200</span>)</span><br><span class="line">m: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">100</span>, <span class="number">2</span> -&gt; <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">var</span> m3 = <span class="type">Map</span>((<span class="number">1</span>,<span class="number">100</span>), (<span class="number">2</span>,<span class="number">200</span>))</span><br><span class="line">m: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">100</span>, <span class="number">2</span> -&gt; <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建map并指定类型、初始化</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> m4:<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">String</span>] = <span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="string">"a"</span>,<span class="number">2</span>-&gt;<span class="string">"b"</span>)</span><br><span class="line">m4: <span class="type">Map</span>[<span class="type">Int</span>,<span class="type">String</span>] = <span class="type">Map</span>(<span class="number">1</span> -&gt; a, <span class="number">2</span> -&gt; b)</span><br></pre></td></tr></table></figure>

<p>读取元素：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; m3(<span class="number">1</span>)</span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">scala&gt; m3.get(<span class="number">1</span>)</span><br><span class="line">res1: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; m3.getOrElse(<span class="number">4</span>, <span class="number">-1</span>)</span><br><span class="line">res2: <span class="type">Int</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取所有元素</span></span><br><span class="line">scala&gt; <span class="keyword">for</span>(e&lt;-m3) println(e._1 + <span class="string">": "</span> + e._2)</span><br><span class="line"><span class="number">1</span>: <span class="number">100</span></span><br><span class="line"><span class="number">2</span>: <span class="number">200</span></span><br><span class="line"><span class="number">3</span>: <span class="number">300</span></span><br><span class="line"></span><br><span class="line">scala&gt; m3.foreach(e=&gt;println(e._1 + <span class="string">": "</span> + e._2))</span><br><span class="line"><span class="number">1</span>: <span class="number">100</span></span><br><span class="line"><span class="number">2</span>: <span class="number">200</span></span><br><span class="line"><span class="number">3</span>: <span class="number">300</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">for</span> ((k,v)&lt;-m3) println(k + <span class="string">": "</span> + v)</span><br><span class="line"><span class="number">1</span>: <span class="number">100</span></span><br><span class="line"><span class="number">2</span>: <span class="number">200</span></span><br><span class="line"><span class="number">3</span>: <span class="number">300</span></span><br></pre></td></tr></table></figure>

<p>也可以进行filter、map操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; m3 filter (e=&gt;e._1&gt;<span class="number">1</span>)</span><br><span class="line">res46: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">200</span>, <span class="number">3</span> -&gt; <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; m3 filterKeys (_&gt;<span class="number">1</span>)</span><br><span class="line">res47: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">200</span>, <span class="number">3</span> -&gt; <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; m3.map(e=&gt;(e._1*<span class="number">10</span>, e._2))</span><br><span class="line">res48: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">10</span> -&gt; <span class="number">100</span>, <span class="number">20</span> -&gt; <span class="number">200</span>, <span class="number">30</span> -&gt; <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; m3 map (e=&gt;e._2)</span><br><span class="line">res49: scala.collection.immutable.<span class="type">Iterable</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于：</span></span><br><span class="line">scala&gt; m3.values.toList</span><br><span class="line">res50: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照key来取对应的value值：</span></span><br><span class="line">scala&gt; <span class="number">2</span> to <span class="number">100</span> flatMap m3.get</span><br><span class="line">res52: scala.collection.immutable.<span class="type">IndexedSeq</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">200</span>, <span class="number">300</span>)</span><br></pre></td></tr></table></figure>

<p>增加、删除、更新：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map本身不可改变，即使定义为var，更新操作也是返回一个新的不可变Map</span></span><br><span class="line">scala&gt; <span class="keyword">var</span> m4 = <span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="number">100</span>)</span><br><span class="line">m4: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; m4 += (<span class="number">2</span>-&gt;<span class="number">200</span>)  <span class="comment">// m4指向新的(1-&gt;100,2-&gt;200), (1-&gt;100)应该被回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种更新方式</span></span><br><span class="line">scala&gt; m4.updated(<span class="number">1</span>,<span class="number">1000</span>)</span><br><span class="line">res7: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">1000</span>, <span class="number">2</span> -&gt; <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加多个元素：</span></span><br><span class="line">scala&gt; <span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="number">100</span>,<span class="number">2</span>-&gt;<span class="number">200</span>) + (<span class="number">3</span>-&gt;<span class="number">300</span>, <span class="number">4</span>-&gt;<span class="number">400</span>)</span><br><span class="line">res8: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">100</span>, <span class="number">2</span> -&gt; <span class="number">200</span>, <span class="number">3</span> -&gt; <span class="number">300</span>, <span class="number">4</span> -&gt; <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素：</span></span><br><span class="line">scala&gt; <span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="number">100</span>,<span class="number">2</span>-&gt;<span class="number">200</span>,<span class="number">3</span>-&gt;<span class="number">300</span>) - (<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line">res9: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="number">100</span>,<span class="number">2</span>-&gt;<span class="number">200</span>,<span class="number">3</span>-&gt;<span class="number">300</span>) -- <span class="type">List</span>(<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line">res10: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并Map：</span></span><br><span class="line">scala&gt; <span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="number">100</span>,<span class="number">2</span>-&gt;<span class="number">200</span>) ++ <span class="type">Map</span>(<span class="number">3</span>-&gt;<span class="number">300</span>) </span><br><span class="line">res11: scala.collection.immutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">100</span>, <span class="number">2</span> -&gt; <span class="number">200</span>, <span class="number">3</span> -&gt; <span class="number">300</span>)</span><br></pre></td></tr></table></figure>

<p><code>对于可变Map</code>的定义和操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> map = scala.collection.mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Any</span>]()</span><br><span class="line">map: scala.collection.mutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Any</span>] = <span class="type">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加元素</span></span><br><span class="line">scala&gt; map(<span class="string">"k1"</span>)=<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加元素</span></span><br><span class="line">scala&gt; map += <span class="string">"k2"</span>-&gt;<span class="string">"v2"</span></span><br><span class="line">res13: map.<span class="keyword">type</span> = <span class="type">Map</span>(k2 -&gt; v2, k1 -&gt; <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断元素值</span></span><br><span class="line">scala&gt; map(<span class="string">"k2"</span>)==<span class="string">"v2"</span></span><br><span class="line">res14: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">scala&gt; map.get(<span class="string">"k2"</span>)==<span class="type">Some</span>(<span class="string">"v2"</span>)</span><br><span class="line">res15: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">scala&gt; map.get(<span class="string">"k3"</span>)==<span class="type">None</span></span><br><span class="line">res16: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> mm = collection.mutable.<span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="number">100</span>,<span class="number">2</span>-&gt;<span class="number">200</span>,<span class="number">3</span>-&gt;<span class="number">300</span>)</span><br><span class="line">mm: scala.collection.mutable.<span class="type">Map</span>[<span class="type">Int</span>,<span class="type">Int</span>] = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">200</span>, <span class="number">1</span> -&gt; <span class="number">100</span>, <span class="number">3</span> -&gt; <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//有则取之，无则加之</span></span><br><span class="line">scala&gt; mm getOrElseUpdate (<span class="number">3</span>,<span class="number">-1</span>)</span><br><span class="line">res17: <span class="type">Int</span> = <span class="number">300</span></span><br><span class="line"></span><br><span class="line">scala&gt; mm getOrElseUpdate (<span class="number">4</span>,<span class="number">-1</span>)</span><br><span class="line">res18: <span class="type">Int</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">scala&gt; mm -= <span class="number">1</span></span><br><span class="line">res19: mm.<span class="keyword">type</span> = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">200</span>, <span class="number">4</span> -&gt; <span class="number">-1</span>, <span class="number">3</span> -&gt; <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">scala&gt; mm -= (<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">res20: mm.<span class="keyword">type</span> = <span class="type">Map</span>(<span class="number">4</span> -&gt; <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个Map</span></span><br><span class="line">scala&gt; mm += (<span class="number">1</span>-&gt;<span class="number">100</span>,<span class="number">2</span>-&gt;<span class="number">200</span>,<span class="number">3</span>-&gt;<span class="number">300</span>)</span><br><span class="line">res21: mm.<span class="keyword">type</span> = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">200</span>, <span class="number">4</span> -&gt; <span class="number">-1</span>, <span class="number">1</span> -&gt; <span class="number">100</span>, <span class="number">3</span> -&gt; <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">scala&gt; mm --= <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">res22: mm.<span class="keyword">type</span> = <span class="type">Map</span>(<span class="number">4</span> -&gt; <span class="number">-1</span>, <span class="number">3</span> -&gt; <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">scala&gt; mm remove <span class="number">1</span></span><br><span class="line">res23: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">None</span></span><br><span class="line"></span><br><span class="line">scala&gt; mm += (<span class="number">1</span>-&gt;<span class="number">100</span>,<span class="number">2</span>-&gt;<span class="number">200</span>,<span class="number">3</span>-&gt;<span class="number">300</span>)</span><br><span class="line">res24: mm.<span class="keyword">type</span> = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">200</span>, <span class="number">4</span> -&gt; <span class="number">-1</span>, <span class="number">1</span> -&gt; <span class="number">100</span>, <span class="number">3</span> -&gt; <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; mm.retain((x,y) =&gt; x&gt;<span class="number">1</span>)</span><br><span class="line">res25: mm.<span class="keyword">type</span> = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">200</span>, <span class="number">4</span> -&gt; <span class="number">-1</span>, <span class="number">3</span> -&gt; <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换操作</span></span><br><span class="line">scala&gt; mm transform ((x,y)=&gt; <span class="number">0</span>)</span><br><span class="line">res26: mm.<span class="keyword">type</span> = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">0</span>, <span class="number">4</span> -&gt; <span class="number">0</span>, <span class="number">3</span> -&gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; mm transform ((x,y)=&gt; x*<span class="number">10</span>)</span><br><span class="line">res27: mm.<span class="keyword">type</span> = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">20</span>, <span class="number">4</span> -&gt; <span class="number">40</span>, <span class="number">3</span> -&gt; <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; mm transform ((x,y)=&gt; y+<span class="number">3</span>)</span><br><span class="line">res28: mm.<span class="keyword">type</span> = <span class="type">Map</span>(<span class="number">2</span> -&gt; <span class="number">23</span>, <span class="number">4</span> -&gt; <span class="number">43</span>, <span class="number">3</span> -&gt; <span class="number">33</span>)</span><br></pre></td></tr></table></figure>

<h2 id="ListMap"><a href="#ListMap" class="headerlink" title="ListMap"></a>ListMap</h2><p><code>ListMap被用来表示一个保存键-值映射的链表</code>。一般情况下，ListMap操作都<strong>需要遍历整个列表</strong>，所以操作的运行时间也同列表长度成线性关系。实际上ListMap在Scala中很少使用，因为标准的不可变映射通常速度会更快。唯一的例外是，在构造映射时由于某种原因，链表中靠前的元素被访问的频率大大高于其他的元素。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> map = scala.collection.immutable.<span class="type">ListMap</span>(<span class="number">1</span>-&gt;<span class="string">"one"</span>, <span class="number">2</span>-&gt;<span class="string">"two"</span>)</span><br><span class="line">map: scala.collection.immutable.<span class="type">ListMap</span>[<span class="type">Int</span>,java.lang.<span class="type">String</span>] = </span><br><span class="line">   <span class="type">Map</span>(<span class="number">1</span> -&gt; one, <span class="number">2</span> -&gt; two)</span><br><span class="line">scala&gt; map(<span class="number">2</span>)</span><br><span class="line">res30: <span class="type">String</span> = <span class="string">"two"</span></span><br></pre></td></tr></table></figure>

<h1 id="不可变Seq实体类"><a href="#不可变Seq实体类" class="headerlink" title="不可变Seq实体类"></a>不可变Seq实体类</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>列表List是一种有限的不可变序列式。</p>
<p>列表定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list:<span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) <span class="comment">// 或者 List(1 to 6:_*)</span></span><br><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>) <span class="comment">// 或者 List('a' to 'd':_*) map (_.toString)</span></span><br></pre></td></tr></table></figure>

<p>合并：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list2 = <span class="string">"a"</span>::<span class="string">"b"</span>::<span class="string">"c"</span>::<span class="type">Nil</span> <span class="comment">// Nil是必须的</span></span><br><span class="line"><span class="keyword">val</span> list3 = <span class="string">"begin"</span> :: list2 <span class="comment">// list2不变，只能加在头，不能加在尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多个List合并用++，也可以用:::(不如++)</span></span><br><span class="line"><span class="keyword">val</span> list4 = list2 ++ <span class="string">"end"</span> ++ <span class="type">Nil</span></span><br><span class="line"><span class="keyword">val</span> list4 = list2 ::: <span class="string">"end"</span> :: <span class="type">Nil</span> <span class="comment">// 相当于 list2 ::: List("end")</span></span><br></pre></td></tr></table></figure>

<p>建议定义方式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> head::body = <span class="type">List</span>(<span class="number">4</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>)</span><br><span class="line"><span class="comment">// head: Any = 4</span></span><br><span class="line"><span class="comment">// body: List[Any] = List(a, b, c, d)</span></span><br><span class="line"><span class="keyword">val</span> a::b::c = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// a: Int = 1</span></span><br><span class="line"><span class="comment">// b: Int = 2</span></span><br><span class="line"><span class="comment">// c: List[Int] = List(3)</span></span><br></pre></td></tr></table></figure>

<p>ListBuffer是可变的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lb = collection.mutable.<span class="type">ListBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">lb += (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line">lb ++= <span class="type">List</span>(<span class="number">9</span>,<span class="number">11</span>) <span class="comment">// ListBuffer(1, 3, 5, 7, 9, 11)</span></span><br><span class="line">lb.toList <span class="comment">// List(1, 3, 5, 7, 9, 11)</span></span><br><span class="line">lb.clear <span class="comment">// ListBuffer()</span></span><br></pre></td></tr></table></figure>

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>流Stream与List很相似，只不过其中的每一个元素都经过了一些简单的计算处理。也正是因为如此，stream结构可以无限长。只有那些被要求的元素才会经过计算处理，除此以外stream结构的性能特性与List基本相同。</p>
<p>鉴于List通常使用<code>::</code>运算符来进行构造，stream使用外观上很相像的<code>#::</code>。这里用一个包含整数1，2和3的stream来做一个简单的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> str = <span class="number">1</span> #:: <span class="number">2</span> #:: <span class="number">3</span> #:: <span class="type">Stream</span>.empty   <span class="comment">//同List的构造，最后一个必须为空</span></span><br><span class="line">str: scala.collection.immutable.<span class="type">Stream</span>[<span class="type">Int</span>] = <span class="type">Stream</span>(<span class="number">1</span>, ?)</span><br></pre></td></tr></table></figure>

<p>该stream的头结点是1，尾是2和3，尾部并没有被打印出来，因为还没有被计算。stream被特别定义为懒惰计算，并且<strong>stream的toString方法很谨慎的设计为不去做任何额外的计算</strong>。</p>
<p>下面给出一个稍复杂些的例子。这里讲一个以两个给定的数字为起始的斐波那契数列转换成stream。斐波那契数列的定义是，序列中的每个元素等于序列中在它之前的两个元素之和。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">fibFrom</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Stream</span>[<span class="type">Int</span>] = a #:: fibFrom(b, a + b)</span><br><span class="line">fibFrom: (a: <span class="type">Int</span>,b: <span class="type">Int</span>)<span class="type">Stream</span>[<span class="type">Int</span>]</span><br></pre></td></tr></table></figure>

<p>这个函数看起来比较简单。序列中的第一个元素显然是a，其余部分是以b和位于其后的a+b为开始斐波那契数列。这段程序最大的亮点是在对序列进行计算的时候避免了无限递归。如果函数中使用<code>::</code>来替换<code>#::</code>，那么之后的每次调用都会产生另一次新的调用，从而导致无限递归。在此例中，由于使用了<code>#::</code>，等式右值中的调用在需要求值之前都不会被展开。这里尝试着打印出以1，1开头的斐波那契数列的前几个元素：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> fibs = fibFrom(<span class="number">1</span>, <span class="number">1</span>).take(<span class="number">7</span>)</span><br><span class="line">fibs: scala.collection.immutable.<span class="type">Stream</span>[<span class="type">Int</span>] = <span class="type">Stream</span>(<span class="number">1</span>, ?)</span><br><span class="line">scala&gt; fibs.toList</span><br><span class="line">res9: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<p>Stream相当于lazy List，避免在中间过程中生成不必要的集合。</p>
<p>例子1：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Range</span>(<span class="number">1</span>,<span class="number">50000000</span>).filter (_ % <span class="number">13</span>==<span class="number">0</span>)(<span class="number">1</span>) <span class="comment">// 26, 但很慢，需要大量内存</span></span><br><span class="line"><span class="type">Stream</span>.range(<span class="number">1</span>,<span class="number">50000000</span>).filter(_%<span class="number">13</span>==<span class="number">0</span>)(<span class="number">1</span>) <span class="comment">// 26，很快，只计算最终结果需要的内容</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>第一个版本在filter后生成一个中间集合，大小为50000000/13；而后者不生成此中间集合，只计算到26即可。</p>
<p>例子2：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">100</span>).map(i=&gt; i*<span class="number">3</span>+<span class="number">7</span>).filter(i=&gt; (i%<span class="number">10</span>)==<span class="number">0</span>).sum <span class="comment">// map和filter生成两个中间collection</span></span><br><span class="line">(<span class="number">1</span> to <span class="number">100</span>).toStream.map(i=&gt; i*<span class="number">3</span>+<span class="number">7</span>).filter(i=&gt; (i%<span class="number">10</span>)==<span class="number">0</span>).sum</span><br></pre></td></tr></table></figure>

<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><code>向量Vector是用来解决列表不能高效的随机访问的一种结构</code>。Vector结构能够在“更高效”的固定时间内<strong>访问到列表中的任意元素</strong>。虽然这个时间会比访问头结点或者访问某数组元素所需的时间长一些，但至少这个时间也是个常量。因此，使用Vector的算法不必仅是小心的处理数据结构的头结点。由于可以快速修改和访问任意位置的元素，所以对Vector结构做写操作很方便。</p>
<p>Seq的缺省实现是List：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Seq</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">res84: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>IndexSeq的缺省实现是Vector:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">IndexedSeq</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">res85: <span class="type">IndexedSeq</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>Vector类型的构建和修改与其他的序列结构基本一样。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> vec = scala.collection.immutable.<span class="type">Vector</span>.empty</span><br><span class="line">vec: scala.collection.immutable.<span class="type">Vector</span>[<span class="type">Nothing</span>] = <span class="type">Vector</span>()</span><br><span class="line">scala&gt; <span class="keyword">val</span> vec2 = vec :+ <span class="number">1</span> :+ <span class="number">2</span></span><br><span class="line">vec2: scala.collection.immutable.<span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> vec3 = <span class="number">100</span> +: vec2</span><br><span class="line">vec3: scala.collection.immutable.<span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">scala&gt; vec3(<span class="number">0</span>)</span><br><span class="line">res1: <span class="type">Int</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>Vector结构通常被表示成具有高分支因子的树（树或者图的分支因子是指数据结构中每个节点的子节点数目）。每一个树节点包含最多32个vector元素或者至多32个子树节点。包含最多32个元素的vector可以表示为一个单一节点，而一个间接引用则可以用来表示一个包含至多32*32=1024个元素的vector。从树的根节点经过两跳到达叶节点足够存下有2的15次方个元素的vector结构，经过3跳可以存2的20次方个，4跳2的25次方个，5跳2的30次方个。所以对于一般大小的vector数据结构，一般经过至多5次数组访问就可以访问到指定的元素。这也就是我们之前所提及的随机数据访问时“运行时间的相对高效”。</p>
<p>由于Vectors结构是不可变的，所以您不能通过修改vector中元素的方法来返回一个新的vector。尽管如此，您仍可以通过update方法从一个单独的元素中创建出区别于给定数据结构的新vector结构：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> vec = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">vec: scala.collection.immutable.<span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">scala&gt; vec updated (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">res0: scala.collection.immutable.<span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">scala&gt; vec</span><br><span class="line">res1: scala.collection.immutable.<span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>从上面例子的最后一行我们可以看出，update方法的调用并不会改变vec的原始值。与元素访问类似，vector的update方法的运行时间也是“相对高效的固定时间”。对vector中的某一元素进行update操作可以通过从树的根节点开始拷贝该节点以及每一个指向该节点的节点中的元素来实现。这就意味着一次update操作能够创建1到5个包含至多32个元素或者子树的树节点。当然，这样做会比就地更新一个可变数组败家很多，但比起拷贝整个vector结构还是绿色环保了不少。</p>
<p>由于vector在快速随机选择和快速随机更新的性能方面做到很好的平衡，所以<strong>它目前正被用作不可变索引序列的默认实现方式</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; collection.immutable.<span class="type">IndexedSeq</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">res2: scala.collection.immutable.<span class="type">IndexedSeq</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>如果您想要实现一个后入先出的序列，那您可以使用Stack。您可以使用push向栈中压入一个元素，用pop从栈中弹出一个元素，用top查看栈顶元素而不用删除它。所有的这些操作都仅仅耗费固定的运行时间。</p>
<p>这里提供几个简单的stack操作的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> stack = scala.collection.immutable.<span class="type">Stack</span>.empty</span><br><span class="line">stack: scala.collection.immutable.<span class="type">Stack</span>[<span class="type">Nothing</span>] = <span class="type">Stack</span>()</span><br><span class="line">scala&gt; <span class="keyword">val</span> hasOne = stack.push(<span class="number">1</span>)</span><br><span class="line">hasOne: scala.collection.immutable.<span class="type">Stack</span>[<span class="type">Int</span>] = <span class="type">Stack</span>(<span class="number">1</span>)</span><br><span class="line">scala&gt; stack</span><br><span class="line">stack: scala.collection.immutable.<span class="type">Stack</span>[<span class="type">Nothing</span>] = <span class="type">Stack</span>()</span><br><span class="line">scala&gt; hasOne.top</span><br><span class="line">res20: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">scala&gt; hasOne.pop</span><br><span class="line">res21: scala.collection.immutable.<span class="type">Stack</span>[<span class="type">Int</span>] = <span class="type">Stack</span>()</span><br></pre></td></tr></table></figure>

<p>不可变stack一般很少用在Scala编程中，因为List结构已经能够覆盖到它的功能：push操作同List中的<code>::</code>基本相同，pop则对应着tail。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue是一种与stack很相似的数据结构，除了与stack的后入先出不同，Queue结构的是先入先出的。</p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>Range表示的是一个有序的等差整数数列。</p>
<p>创建 Range：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Range</span>(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">res58: scala.collection.immutable.<span class="type">Range</span> = <span class="type">Range</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">scala&gt; <span class="number">0</span> until <span class="number">5</span></span><br><span class="line">res59: scala.collection.immutable.<span class="type">Range</span> = <span class="type">Range</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line">scala&gt; <span class="number">0</span> to <span class="number">4</span></span><br><span class="line">res60: scala.collection.immutable.<span class="type">Range</span>.<span class="type">Inclusive</span> = <span class="type">Range</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>两个Range相加：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; ('<span class="number">0</span>' to '<span class="number">9</span>') ++ ('<span class="type">A</span>' to '<span class="type">Z</span>')</span><br><span class="line">res61: scala.collection.immutable.<span class="type">IndexedSeq</span>[<span class="type">Char</span>] = <span class="type">Vector</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>, <span class="type">D</span>, <span class="type">E</span>, <span class="type">F</span>, <span class="type">G</span>, <span class="type">H</span>, <span class="type">I</span>, <span class="type">J</span>, <span class="type">K</span>, <span class="type">L</span>, <span class="type">M</span>, <span class="type">N</span>, <span class="type">O</span>, <span class="type">P</span>, <span class="type">Q</span>, <span class="type">R</span>, <span class="type">S</span>, <span class="type">T</span>, <span class="type">U</span>, <span class="type">V</span>, <span class="type">W</span>, <span class="type">X</span>, <span class="type">Y</span>, <span class="type">Z</span>)</span><br></pre></td></tr></table></figure>

<p>Range和List、Vector转换：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="number">1</span> to <span class="number">5</span> toList</span><br><span class="line">warning: there were <span class="number">1</span> feature warning(s); re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</span><br><span class="line">res62: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当与：</span></span><br><span class="line">scala&gt; <span class="type">List</span>(<span class="number">1</span> to <span class="number">5</span>:_*)</span><br><span class="line">res63: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者：</span></span><br><span class="line">scala&gt; <span class="type">Vector</span>(<span class="number">1</span> to <span class="number">5</span>: _*)</span><br><span class="line">res64: scala.collection.immutable.<span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>数组定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">0</span>) <span class="comment">// Array()</span></span><br><span class="line"><span class="keyword">val</span> list2 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>) <span class="comment">// Array(null, null, null)</span></span><br><span class="line"><span class="keyword">val</span> list3:<span class="type">Array</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Array</span>(<span class="number">3</span>) <span class="comment">// // Array(null, null, null)</span></span><br><span class="line"><span class="keyword">val</span> list1 = <span class="type">Array</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>) <span class="comment">// 相当于Array.apply("a","b","c","d")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类型为Any的Array：</span></span><br><span class="line"><span class="keyword">val</span> aa = <span class="type">Array</span>[<span class="type">Any</span>](<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> aa: <span class="type">Array</span>[<span class="type">Any</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> aa: <span class="type">Array</span>[_] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="type">Array</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>)</span><br><span class="line"><span class="type">Array</span>[<span class="type">Int</span>](<span class="number">1</span> to <span class="number">11</span> by <span class="number">2</span>:_*)</span><br></pre></td></tr></table></figure>

<p>与Array对应的可变ArrayBuffer：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ab = collection.mutable.<span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">ab += (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>)</span><br><span class="line">ab ++= <span class="type">List</span>(<span class="number">9</span>,<span class="number">11</span>) <span class="comment">// ArrayBuffer(1, 3, 5, 7, 9, 11)</span></span><br><span class="line">ab toArray <span class="comment">// Array (1, 3, 5, 7, 9, 11)</span></span><br><span class="line">ab clear <span class="comment">// ArrayBuffer()</span></span><br></pre></td></tr></table></figure>

<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><p>定义方式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t1 = (<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">var</span> t2 = (<span class="string">"a"</span>, <span class="number">123</span>, <span class="number">3.14</span>, <span class="keyword">new</span> <span class="type">Date</span>())</span><br><span class="line"><span class="keyword">val</span> (a,b,c) = (<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>最简单的Tuple：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>-&gt;<span class="string">"hello world"</span></span><br></pre></td></tr></table></figure>

<p>和下面的写法是等价的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://twitter.github.io/scala_school/zh_cn/index.html" target="_blank" rel="noopener">Scala 课堂</a></li>
<li><a href="http://qiujj.com/static/Scala-Handbook.htm" target="_blank" rel="noopener">Scala 2.8+ Handbook</a></li>
<li><a href="https://code.csdn.net/DOC_Scala/chinese_scala_offical_document/file/Introduction.md#anchor_0" target="_blank" rel="noopener">CSDN CODE翻译的Scala容器库(Scala’s Collections Library)</a></li>
</ul>

      
    </div>

    

    
    
    


    
      <div>
        




  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>JavaChen</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="http://javachen.github.io/2015/04/22/scala-collections/" title="Scala集合">Scala集合</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="JavaChen 微信支付">
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="JavaChen 支付宝">
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    



    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/scala/" rel="tag"><i class="fa fa-tag"></i> scala</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
            
              <div>
                
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

              </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/04/20/basic-of-scala/" rel="next" title="Scala基本语法和概念">
                <i class="fa fa-chevron-left"></i> Scala基本语法和概念
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/04/23/all-the-uses-of-an-underscore-in-scala/" rel="prev" title="Scala中下划线的用途">
                Scala中下划线的用途 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2009 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JavaChen</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').not('.gist .highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      const selection = document.getSelection();
      const selected = selection.rangeCount > 0 ? selection.getRangeAt(0) : false;
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
      ta.blur(); // For iOS
      $(this).blur();
      if (selected) {
        selection.removeAllRanges();
        selection.addRange(selected);
      }
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
