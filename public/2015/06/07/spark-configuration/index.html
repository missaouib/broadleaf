<!DOCTYPE html>













<html class="theme-next mist" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.css">
















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






  

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.2',
    sidebar: {"position":"left","display":"remove","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本文主要整理Spark的相关配置参数，便于查询和方便调优。">
<meta name="keywords" content="spark">
<meta property="og:type" content="article">
<meta property="og:title" content="Spark配置参数">
<meta property="og:url" content="http://javachen.github.io/2015/06/07/spark-configuration/index.html">
<meta property="og:site_name" content="JavaChen Blog">
<meta property="og:description" content="本文主要整理Spark的相关配置参数，便于查询和方便调优。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-06-29T12:23:34.046Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spark配置参数">
<meta name="twitter:description" content="本文主要整理Spark的相关配置参数，便于查询和方便调优。">



  <link rel="alternate" href="/atom.xml" title="JavaChen Blog" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://javachen.github.io/2015/06/07/spark-configuration/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Spark配置参数 | JavaChen Blog</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?50bc6f5d9b045b5895ff44f8bbdbc611";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JavaChen Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">Ramblings of a coder</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://javachen.github.io/2015/06/07/spark-configuration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JavaChen">
      <meta itemprop="description" content="Rumblings by a coder on Java、Hadoop and so on">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JavaChen Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Spark配置参数<a href="https://github.com/javachen/javachen-blog-theme/tree/master/source/_posts/2015/2015-06-07-spark-configuration.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil"></i></a>

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2015-06-07 00:00:00" itemprop="dateCreated datePublished" datetime="2015-06-07T00:00:00+08:00">2015-06-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-29 20:23:34" itemprop="dateModified" datetime="2019-06-29T20:23:34+08:00">2019-06-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/spark/" itemprop="url" rel="index"><span itemprop="name">spark</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <!--/删除
          
              <div class="post-description">
                  本文主要整理Spark的相关配置参数，便于查询和方便调优。
              </div>
          
          -->

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>以下是整理的Spark中的一些配置参数，官方文档请参考<a href="https:/.apache.org/docs/latest/configuration.html" target="_blank" rel="noopener">Spark Configuration</a>。</p>
<p>Spark提供三个位置用来配置系统：</p>
<ul>
<li>Spark属性：控制大部分的应用程序参数，可以用SparkConf对象或者Java系统属性设置</li>
<li>环境变量：可以通过每个节点的<code>conf-env.sh</code>脚本设置。例如IP地址、端口等信息</li>
<li>日志配置：可以通过log4j.properties配置</li>
</ul>
<h1 id="Spark属性"><a href="#Spark属性" class="headerlink" title="Spark属性"></a>Spark属性</h1><p>Spark属性控制大部分的应用程序设置，并且为每个应用程序分别配置它。这些属性可以直接在<a href="http:/.apache.org/docs/latest/api/scala/index.html#org.apache.spark.SparkConf" target="_blank" rel="noopener">SparkConf</a>上配置，然后传递给<code>SparkContext</code>。<code>SparkConf</code><br>允许你配置一些通用的属性（如master URL、应用程序名称等等）以及通过<code>set()</code>方法设置的任意键值对。例如，我们可以用如下方式创建一个拥有两个线程的应用程序。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">             .setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">             .setAppName(<span class="string">"CountingSheep"</span>)</span><br><span class="line">             .set(<span class="string">"spark.executor.memory"</span>, <span class="string">"1g"</span>)</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br></pre></td></tr></table></figure>

<h2 id="动态加载Spark属性"><a href="#动态加载Spark属性" class="headerlink" title="动态加载Spark属性"></a>动态加载Spark属性</h2><p>在一些情况下，你可能想在<code>SparkConf</code>中避免硬编码确定的配置。例如，你想用不同的master或者不同的内存数运行相同的应用程序。Spark允许你简单地创建一个空conf。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>())</span><br></pre></td></tr></table></figure>

<p>然后你在运行时设置变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin-submit --name <span class="string">"My app"</span> --master <span class="built_in">local</span>[4] --conf spark.shuffle.spill=<span class="literal">false</span></span><br><span class="line">  --conf <span class="string">"spark.executor.extraJavaOptions=-XX:+PrintGCDetails -XX:+PrintGCTimeStamps"</span> myApp.jar</span><br></pre></td></tr></table></figure>

<p>Spark shell和<code>spark-submit</code>工具支持两种方式动态加载配置。第一种方式是命令行选项，例如<code>--master</code>，如上面shell显示的那样。<code>spark-submit</code>可以接受任何Spark属性，用<code>--conf</code>参数表示。但是那些参与Spark应用程序启动的属性要用特定的参数表示。运行<code>./bin-submit --help</code>将会显示选项的整个列表。</p>
<p><code>bin-submit</code>也会从<code>conf-defaults.conf</code>中读取配置选项，这个配置文件中，每一行都包含一对以<code>空格</code>或者<code>等号</code>分开的键和值。例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spark<span class="selector-class">.master</span>            spark:<span class="comment">//5.6.7.8:7077</span></span><br><span class="line">spark<span class="selector-class">.executor</span><span class="selector-class">.memory</span>   <span class="number">512</span>m</span><br><span class="line">spark<span class="selector-class">.eventLog</span><span class="selector-class">.enabled</span>  true</span><br><span class="line">spark<span class="selector-class">.serializer</span>        org<span class="selector-class">.apache</span><span class="selector-class">.spark</span><span class="selector-class">.serializer</span><span class="selector-class">.KryoSerializer</span></span><br></pre></td></tr></table></figure>

<p>任何标签指定的值或者在配置文件中的值将会传递给应用程序，并且通过<code>SparkConf</code>合并这些值。在<code>SparkConf</code>上设置的属性具有最高的优先级，其次是传递给<code>spark-submit</code>或者<code>spark-shell</code>的属性值，最后是<code>spark-defaults.conf</code>文件中的属性值。</p>
<p>优先级顺序：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SparkConf &gt; <span class="keyword">CLI</span> &gt; spark-defaults.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>

<h2 id="查看Spark属性"><a href="#查看Spark属性" class="headerlink" title="查看Spark属性"></a>查看Spark属性</h2><p>在<code>http://&lt;driver&gt;:4040</code>上的应用程序Web UI在<code>Environment</code>标签中列出了所有的Spark属性。这对你确保设置的属性的正确性是很有用的。</p>
<p>注意：<code>只有通过spark-defaults.conf, SparkConf以及命令行直接指定的值才会显示</code>。对于其它的配置属性，你可以认为程序用到了默认的值。</p>
<h2 id="可用的属性"><a href="#可用的属性" class="headerlink" title="可用的属性"></a>可用的属性</h2><p>控制内部设置的大部分属性都有合理的默认值，一些最通用的选项设置如下：</p>
<h3 id="应用程序属性"><a href="#应用程序属性" class="headerlink" title="应用程序属性"></a>应用程序属性</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.app.name</td>
<td>(none)</td>
<td>你的应用程序的名字。这将在UI和日志数据中出现</td>
</tr>
<tr>
<td>spark.driver.cores</td>
<td>1</td>
<td>driver程序运行需要的cpu内核数</td>
</tr>
<tr>
<td>spark.driver.maxResultSize</td>
<td>1g</td>
<td>每个Spark action(如collect)所有分区的序列化结果的总大小限制。设置的值应该不小于1m，0代表没有限制。如果总大小超过这个限制，程序将会终止。大的限制值可能导致driver出现内存溢出错误（依赖于<code>spark.driver.memory</code>和JVM中对象的内存消耗）。</td>
</tr>
<tr>
<td>spark.driver.memory</td>
<td>512m</td>
<td>driver进程使用的内存数</td>
</tr>
<tr>
<td>spark.executor.memory</td>
<td>512m</td>
<td>每个executor进程使用的内存数。和JVM内存串拥有相同的格式（如512m,2g）</td>
</tr>
<tr>
<td>spark.extraListeners</td>
<td>(none)</td>
<td>注册监听器，需要实现SparkListener</td>
</tr>
<tr>
<td>spark.local.dir</td>
<td>/tmp</td>
<td>Spark中暂存空间的使用目录。在Spark1.0以及更高的版本中，这个属性被SPARK_LOCAL_DIRS(Standalone, Mesos)和LOCAL_DIRS(YARN)环境变量覆盖。</td>
</tr>
<tr>
<td>spark.logConf</td>
<td>false</td>
<td>当SparkContext启动时，将有效的SparkConf记录为INFO。</td>
</tr>
<tr>
<td>spark.master</td>
<td>(none)</td>
<td>集群管理器连接的地方</td>
</tr>
</tbody></table>
<h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.driver.extraClassPath</td>
<td>(none)</td>
<td>附加到driver的classpath的额外的classpath实体。</td>
</tr>
<tr>
<td>spark.driver.extraJavaOptions</td>
<td>(none)</td>
<td>传递给driver的JVM选项字符串。例如GC设置或者其它日志设置。注意，<code>在这个选项中设置Spark属性或者堆大小是不合法的</code>。Spark属性需要用<code>--driver-class-path</code>设置。</td>
</tr>
<tr>
<td>spark.driver.extraLibraryPath</td>
<td>(none)</td>
<td>指定启动driver的JVM时用到的库路径</td>
</tr>
<tr>
<td>spark.driver.userClassPathFirst</td>
<td>false</td>
<td>(实验性)当在driver中加载类时，是否用户添加的jar比Spark自己的jar优先级高。这个属性可以降低Spark依赖和用户依赖的冲突。它现在还是一个实验性的特征。</td>
</tr>
<tr>
<td>spark.executor.extraClassPath</td>
<td>(none)</td>
<td>附加到executors的classpath的额外的classpath实体。这个设置存在的主要目的是Spark与旧版本的向后兼容问题。用户一般不用设置这个选项</td>
</tr>
<tr>
<td>spark.executor.extraJavaOptions</td>
<td>(none)</td>
<td>传递给executors的JVM选项字符串。例如GC设置或者其它日志设置。注意，<code>在这个选项中设置Spark属性或者堆大小是不合法的</code>。Spark属性需要用SparkConf对象或者<code>spark-submit</code>脚本用到的<code>spark-defaults.conf</code>文件设置。堆内存可以通过<code>spark.executor.memory</code>设置</td>
</tr>
<tr>
<td>spark.executor.extraLibraryPath</td>
<td>(none)</td>
<td>指定启动executor的JVM时用到的库路径</td>
</tr>
<tr>
<td>spark.executor.logs.rolling.maxRetainedFiles</td>
<td>(none)</td>
<td>设置被系统保留的最近滚动日志文件的数量。更老的日志文件将被删除。默认没有开启。</td>
</tr>
<tr>
<td>spark.executor.logs.rolling.size.maxBytes</td>
<td>(none)</td>
<td>executor日志的最大滚动大小。默认情况下没有开启。值设置为字节</td>
</tr>
<tr>
<td>spark.executor.logs.rolling.strategy</td>
<td>(none)</td>
<td>设置executor日志的滚动(rolling)策略。默认情况下没有开启。可以配置为<code>time</code>和<code>size</code>。对于<code>time</code>，用<code>spark.executor.logs.rolling.time.interval</code>设置滚动间隔；对于<code>size</code>，用<code>spark.executor.logs.rolling.size.maxBytes</code>设置最大的滚动大小</td>
</tr>
<tr>
<td>spark.executor.logs.rolling.time.interval</td>
<td>daily</td>
<td>executor日志滚动的时间间隔。默认情况下没有开启。合法的值是<code>daily</code>, <code>hourly</code>, <code>minutely</code>以及任意的秒。</td>
</tr>
<tr>
<td>spark.files.userClassPathFirst</td>
<td>false</td>
<td>(实验性)当在Executors中加载类时，是否用户添加的jar比Spark自己的jar优先级高。这个属性可以降低Spark依赖和用户依赖的冲突。它现在还是一个实验性的特征。</td>
</tr>
<tr>
<td>spark.python.worker.memory</td>
<td>512m</td>
<td>在聚合期间，每个python worker进程使用的内存数。在聚合期间，如果内存超过了这个限制，它将会将数据塞进磁盘中</td>
</tr>
<tr>
<td>spark.python.profile</td>
<td>false</td>
<td>在Python worker中开启profiling。通过<code>sc.show_profiles()</code>展示分析结果。或者在driver退出前展示分析结果。可以通过<code>sc.dump_profiles(path)</code>将结果dump到磁盘中。如果一些分析结果已经手动展示，那么在driver退出前，它们再不会自动展示</td>
</tr>
<tr>
<td>spark.python.profile.dump</td>
<td>(none)</td>
<td>driver退出前保存分析结果的dump文件的目录。每个RDD都会分别dump一个文件。可以通过<code>ptats.Stats()</code>加载这些文件。如果指定了这个属性，分析结果不会自动展示</td>
</tr>
<tr>
<td>spark.python.worker.reuse</td>
<td>true</td>
<td>是否重用python worker。如果是，它将使用固定数量的Python workers，而不需要为每个任务<code>fork()</code>一个Python进程。如果有一个非常大的广播，这个设置将非常有用。因为，广播不需要为每个任务从JVM到Python worker传递一次</td>
</tr>
<tr>
<td>spark.executorEnv.[EnvironmentVariableName]</td>
<td>(none)</td>
<td>通过<code>EnvironmentVariableName</code>添加指定的环境变量到executor进程。用户可以指定多个<code>EnvironmentVariableName</code>，设置多个环境变量</td>
</tr>
<tr>
<td>spark.mesos.executor.home</td>
<td>driver side SPARK_HOME</td>
<td>设置安装在Mesos的executor上的Spark的目录。默认情况下，executors将使用driver的Spark本地（home）目录，这个目录对它们不可见。注意，如果没有通过<code>spark.executor.uri</code>指定Spark的二进制包，这个设置才起作用</td>
</tr>
<tr>
<td>spark.mesos.executor.memoryOverhead</td>
<td>executor memory * 0.07, 最小384m</td>
<td>这个值是<code>spark.executor.memory</code>的补充。它用来计算mesos任务的总内存。另外，有一个7%的硬编码设置。最后的值将选择<code>spark.mesos.executor.memoryOverhead</code>或者<code>spark.executor.memory</code>的7%二者之间的大者</td>
</tr>
</tbody></table>
<h3 id="Shuffle行为"><a href="#Shuffle行为" class="headerlink" title="Shuffle行为"></a>Shuffle行为</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.reducer.maxMbInFlight</td>
<td>48</td>
<td>从递归任务中同时获取的map输出数据的最大大小（mb）。因为每一个输出都需要我们创建一个缓存用来接收，这个设置代表每个任务固定的内存上限，所以除非你有更大的内存，将其设置小一点</td>
</tr>
<tr>
<td>spark.shuffle.blockTransferService</td>
<td>netty</td>
<td>实现用来在executor直接传递shuffle和缓存块。有两种可用的实现：<code>netty</code>和<code>nio</code>。基于netty的块传递在具有相同的效率情况下更简单</td>
</tr>
<tr>
<td>spark.shuffle.compress</td>
<td>true</td>
<td>是否压缩map操作的输出文件。一般情况下，这是一个好的选择。</td>
</tr>
<tr>
<td>spark.shuffle.consolidateFiles</td>
<td>false</td>
<td>如果设置为”true”，在shuffle期间，合并的中间文件将会被创建。创建更少的文件可以提供文件系统的shuffle的效率。这些shuffle都伴随着大量递归任务。当用ext4和dfs文件系统时，推荐设置为”true”。在ext3中，因为文件系统的限制，这个选项可能机器（大于8核）降低效率</td>
</tr>
<tr>
<td>spark.shuffle.file.buffer.kb</td>
<td>32</td>
<td>每个shuffle文件输出流内存内缓存的大小，单位是kb。这个缓存减少了创建只中间shuffle文件中磁盘搜索和系统访问的数量</td>
</tr>
<tr>
<td>spark.shuffle.io.maxRetries</td>
<td>3</td>
<td>Netty only，自动重试次数</td>
</tr>
<tr>
<td>spark.shuffle.io.numConnectionsPerPeer</td>
<td>1</td>
<td>Netty only</td>
</tr>
<tr>
<td>spark.shuffle.io.preferDirectBufs</td>
<td>true</td>
<td>Netty only</td>
</tr>
<tr>
<td>spark.shuffle.io.retryWait</td>
<td>5</td>
<td>Netty only</td>
</tr>
<tr>
<td>spark.shuffle.manager</td>
<td>sort</td>
<td>它的实现用于shuffle数据。有两种可用的实现：<code>sort</code>和<code>hash</code>。基于sort的shuffle有更高的内存使用率</td>
</tr>
<tr>
<td>spark.shuffle.memoryFraction</td>
<td>0.2</td>
<td>如果<code>spark.shuffle.spill</code>为true，shuffle中聚合和合并组操作使用的java堆内存占总内存的比重。在任何时候，shuffles使用的所有内存内maps的集合大小都受这个限制的约束。超过这个限制，spilling数据将会保存到磁盘上。如果spilling太过频繁，考虑增大这个值</td>
</tr>
<tr>
<td>spark.shuffle.sort.bypassMergeThreshold</td>
<td>200</td>
<td>(Advanced) In the sort-based shuffle manager, avoid merge-sorting data if there is no map-side aggregation and there are at most this many reduce partitions</td>
</tr>
<tr>
<td>spark.shuffle.spill</td>
<td>true</td>
<td>如果设置为”true”，通过将多出的数据写入磁盘来限制内存数。通过<code>spark.shuffle.memoryFraction</code>来指定spilling的阈值</td>
</tr>
<tr>
<td>spark.shuffle.spill.compress</td>
<td>true</td>
<td>在shuffle时，是否将spilling的数据压缩。压缩算法通过<code>spark.io.compression.codec</code>指定。</td>
</tr>
</tbody></table>
<h3 id="Spark-UI"><a href="#Spark-UI" class="headerlink" title="Spark UI"></a>Spark UI</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.eventLog.compress</td>
<td>false</td>
<td>是否压缩事件日志。需要<code>spark.eventLog.enabled</code>为true</td>
</tr>
<tr>
<td>spark.eventLog.dir</td>
<td>file:///tmp-events</td>
<td>Spark事件日志记录的基本目录。在这个基本目录下，Spark为每个应用程序创建一个子目录。各个应用程序记录日志到直到的目录。用户可能想设置这为统一的地点，像HDFS一样，所以历史文件可以通过历史服务器读取</td>
</tr>
<tr>
<td>spark.eventLog.enabled</td>
<td>false</td>
<td>是否记录Spark的事件日志。这在应用程序完成后，重新构造web UI是有用的</td>
</tr>
<tr>
<td>spark.ui.killEnabled</td>
<td>true</td>
<td>运行在web UI中杀死stage和相应的job</td>
</tr>
<tr>
<td>spark.ui.port</td>
<td>4040</td>
<td>你的应用程序dashboard的端口。显示内存和工作量数据</td>
</tr>
<tr>
<td>spark.ui.retainedJobs</td>
<td>1000</td>
<td>在垃圾回收之前，Spark UI和状态API记住的job数</td>
</tr>
<tr>
<td>spark.ui.retainedStages</td>
<td>1000</td>
<td>在垃圾回收之前，Spark UI和状态API记住的stage数</td>
</tr>
</tbody></table>
<h3 id="压缩和序列化"><a href="#压缩和序列化" class="headerlink" title="压缩和序列化"></a>压缩和序列化</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.broadcast.compress</td>
<td>true</td>
<td>在发送广播变量之前是否压缩它</td>
</tr>
<tr>
<td>spark.closure.serializer</td>
<td>org.apache.spark.serializer.JavaSerializer</td>
<td>闭包用到的序列化类。目前只支持java序列化器</td>
</tr>
<tr>
<td>spark.io.compression.codec</td>
<td>snappy</td>
<td>压缩诸如RDD分区、广播变量、shuffle输出等内部数据的编码解码器。默认情况下，Spark提供了三种选择：lz4、lzf和snappy，你也可以用完整的类名来制定。</td>
</tr>
<tr>
<td>spark.io.compression.lz4.block.size</td>
<td>32768</td>
<td>LZ4压缩中用到的块大小。降低这个块的大小也会降低shuffle内存使用率</td>
</tr>
<tr>
<td>spark.io.compression.snappy.block.size</td>
<td>32768</td>
<td>Snappy压缩中用到的块大小。降低这个块的大小也会降低shuffle内存使用率</td>
</tr>
<tr>
<td>spark.kryo.classesToRegister</td>
<td>(none)</td>
<td>如果你用Kryo序列化，给定的用逗号分隔的自定义类名列表表示要注册的类</td>
</tr>
<tr>
<td>spark.kryo.referenceTracking</td>
<td>true</td>
<td>当用Kryo序列化时，跟踪是否引用同一对象。如果你的对象图有环，这是必须的设置。如果他们包含相同对象的多个副本，这个设置对效率是有用的。如果你知道不在这两个场景，那么可以禁用它以提高效率</td>
</tr>
<tr>
<td>spark.kryo.registrationRequired</td>
<td>false</td>
<td>是否需要注册为Kyro可用。如果设置为true，然后如果一个没有注册的类序列化，Kyro会抛出异常。如果设置为false，Kryo将会同时写每个对象和其非注册类名。写类名可能造成显著地性能瓶颈。</td>
</tr>
<tr>
<td>spark.kryo.registrator</td>
<td>(none)</td>
<td>如果你用Kryo序列化，设置这个类去注册你的自定义类。如果你需要用自定义的方式注册你的类，那么这个属性是有用的。否则<code>spark.kryo.classesToRegister</code>会更简单。它应该设置一个继承自<a href="http:/.apache.org/docs/latest/api/scala/index.html#org.apache.spark.serializer.KryoRegistrator" target="_blank" rel="noopener">KryoRegistrator</a>的类</td>
</tr>
<tr>
<td>spark.kryoserializer.buffer.max.mb</td>
<td>64</td>
<td>Kryo序列化缓存允许的最大值。这个值必须大于你尝试序列化的对象</td>
</tr>
<tr>
<td>spark.kryoserializer.buffer.mb</td>
<td>0.064</td>
<td>Kyro序列化缓存的大小。这样worker上的每个核都有一个缓存。如果有需要，缓存会涨到<code>spark.kryoserializer.buffer.max.mb</code>设置的值那么大。</td>
</tr>
<tr>
<td>spark.rdd.compress</td>
<td>true</td>
<td>是否压缩序列化的RDD分区。在花费一些额外的CPU时间的同时节省大量的空间</td>
</tr>
<tr>
<td>spark.serializer</td>
<td>org.apache.spark.serializer.JavaSerializer</td>
<td>序列化对象使用的类。默认的Java序列化类可以序列化任何可序列化的java对象但是它很慢。所有我们建议用<a href="http:/.apache.org/docs/latest/tuning.html" target="_blank" rel="noopener">org.apache.spark.serializer.KryoSerializer</a></td>
</tr>
<tr>
<td>spark.serializer.objectStreamReset</td>
<td>100</td>
<td>当用<code>org.apache.spark.serializer.JavaSerializer</code>序列化时，序列化器通过缓存对象防止写多余的数据，然而这会造成这些对象的垃圾回收停止。通过请求’reset’，你从序列化器中flush这些信息并允许收集老的数据。为了关闭这个周期性的reset，你可以将值设为-1。默认情况下，每一百个对象reset一次</td>
</tr>
</tbody></table>
<h3 id="运行时行为"><a href="#运行时行为" class="headerlink" title="运行时行为"></a>运行时行为</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.broadcast.blockSize</td>
<td>4096</td>
<td>TorrentBroadcastFactory传输的块大小，太大值会降低并发，太小的值会出现性能瓶颈</td>
</tr>
<tr>
<td>spark.broadcast.factory</td>
<td>org.apache.spark.broadcast.TorrentBroadcastFactory</td>
<td>broadcast实现类</td>
</tr>
<tr>
<td>spark.cleaner.ttl</td>
<td>(infinite)</td>
<td>spark记录任何元数据（stages生成、task生成等）的持续时间。定期清理可以确保将超期的元数据丢弃，这在运行长时间任务是很有用的，如运行7*24的sparkstreaming任务。RDD持久化在内存中的超期数据也会被清理</td>
</tr>
<tr>
<td>spark.default.parallelism</td>
<td>本地模式：机器核数；Mesos：8；其他：<code>max(executor的core，2)</code></td>
<td>如果用户不设置，系统使用集群中运行shuffle操作的默认任务数（groupByKey、 reduceByKey等）</td>
</tr>
<tr>
<td>spark.executor.heartbeatInterval</td>
<td>10000</td>
<td>executor 向 the driver 汇报心跳的时间间隔，单位毫秒</td>
</tr>
<tr>
<td>spark.files.fetchTimeout</td>
<td>60</td>
<td>driver 程序获取通过<code>SparkContext.addFile()</code>添加的文件时的超时时间，单位秒</td>
</tr>
<tr>
<td>spark.files.useFetchCache</td>
<td>true</td>
<td>获取文件时是否使用本地缓存</td>
</tr>
<tr>
<td>spark.files.overwrite</td>
<td>false</td>
<td>调用<code>SparkContext.addFile()</code>时候是否覆盖文件</td>
</tr>
<tr>
<td>spark.hadoop.cloneConf</td>
<td>false</td>
<td>每个task是否克隆一份hadoop的配置文件</td>
</tr>
<tr>
<td>spark.hadoop.validateOutputSpecs</td>
<td>true</td>
<td>是否校验输出</td>
</tr>
<tr>
<td>spark.storage.memoryFraction</td>
<td>0.6</td>
<td>Spark内存缓存的堆大小占用总内存比例，该值不能大于老年代内存大小，默认值为0.6，但是，如果你手动设置老年代大小，你可以增加该值</td>
</tr>
<tr>
<td>spark.storage.memoryMapThreshold</td>
<td>2097152</td>
<td>内存块大小</td>
</tr>
<tr>
<td>spark.storage.unrollFraction</td>
<td>0.2</td>
<td>Fraction of spark.storage.memoryFraction to use for unrolling blocks in memory.</td>
</tr>
<tr>
<td>spark.tachyonStore.baseDir</td>
<td>System.getProperty(“java.io.tmpdir”)</td>
<td>Tachyon File System临时目录</td>
</tr>
<tr>
<td>spark.tachyonStore.url</td>
<td>tachyon://localhost:19998</td>
<td>Tachyon File System URL</td>
</tr>
</tbody></table>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.driver.host</td>
<td>(local hostname)</td>
<td>driver监听的主机名或者IP地址。这用于和executors以及独立的master通信</td>
</tr>
<tr>
<td>spark.driver.port</td>
<td>(random)</td>
<td>driver监听的接口。这用于和executors以及独立的master通信</td>
</tr>
<tr>
<td>spark.fileserver.port</td>
<td>(random)</td>
<td>driver的文件服务器监听的端口</td>
</tr>
<tr>
<td>spark.broadcast.port</td>
<td>(random)</td>
<td>driver的HTTP广播服务器监听的端口</td>
</tr>
<tr>
<td>spark.replClassServer.port</td>
<td>(random)</td>
<td>driver的HTTP类服务器监听的端口</td>
</tr>
<tr>
<td>spark.blockManager.port</td>
<td>(random)</td>
<td>块管理器监听的端口。这些同时存在于driver和executors</td>
</tr>
<tr>
<td>spark.executor.port</td>
<td>(random)</td>
<td>executor监听的端口。用于与driver通信</td>
</tr>
<tr>
<td>spark.port.maxRetries</td>
<td>16</td>
<td>当绑定到一个端口，在放弃前重试的最大次数</td>
</tr>
<tr>
<td>spark.akka.frameSize</td>
<td>10</td>
<td>在”control plane”通信中允许的最大消息大小。如果你的任务需要发送大的结果到driver中，调大这个值</td>
</tr>
<tr>
<td>spark.akka.threads</td>
<td>4</td>
<td>通信的actor线程数。当driver有很多CPU核时，调大它是有用的</td>
</tr>
<tr>
<td>spark.akka.timeout</td>
<td>100</td>
<td>Spark节点之间的通信超时。单位是秒</td>
</tr>
<tr>
<td>spark.akka.heartbeat.pauses</td>
<td>6000</td>
<td>This is set to a larger value to disable failure detector that comes inbuilt akka. It can be enabled again, if you plan to use this feature (Not recommended). Acceptable heart beat pause in seconds for akka. This can be used to control sensitivity to gc pauses. Tune this in combination of <code>spark.akka.heartbeat.interval</code> and <code>spark.akka.failure-detector.threshold</code> if you need to.</td>
</tr>
<tr>
<td>spark.akka.failure-detector.threshold</td>
<td>300.0</td>
<td>This is set to a larger value to disable failure detector that comes inbuilt akka. It can be enabled again, if you plan to use this feature (Not recommended). This maps to akka’s <code>akka.remote.transport-failure-detector.threshold</code>. Tune this in combination of <code>spark.akka.heartbeat.pauses</code> and <code>spark.akka.heartbeat.interval</code> if you need to.</td>
</tr>
<tr>
<td>spark.akka.heartbeat.interval</td>
<td>1000</td>
<td>This is set to a larger value to disable failure detector that comes inbuilt akka. It can be enabled again, if you plan to use this feature (Not recommended). A larger interval value in seconds reduces network overhead and a smaller value ( ~ 1 s) might be more informative for akka’s failure detector. Tune this in combination of <code>spark.akka.heartbeat.pauses</code> and <code>spark.akka.failure-detector.threshold</code> if you need to. Only positive use case for using failure detector can be, a sensistive failure detector can help evict rogue executors really quick. However this is usually not the case as gc pauses and network lags are expected in a real Spark cluster. Apart from that enabling this leads to a lot of exchanges of heart beats between nodes leading to flooding the network with those.</td>
</tr>
</tbody></table>
<h3 id="调度相关属性"><a href="#调度相关属性" class="headerlink" title="调度相关属性"></a>调度相关属性</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.task.cpus</td>
<td>1</td>
<td>为每个任务分配的内核数</td>
</tr>
<tr>
<td>spark.task.maxFailures</td>
<td>4</td>
<td>Task的最大重试次数</td>
</tr>
<tr>
<td>spark.scheduler.mode</td>
<td>FIFO</td>
<td>Spark的任务调度模式，还有一种Fair模式</td>
</tr>
<tr>
<td>spark.cores.max</td>
<td></td>
<td>当应用程序运行在Standalone集群或者粗粒度共享模式Mesos集群时，应用程序向集群请求的最大CPU内核总数（不是指每台机器，而是整个集群）。如果不设置，对于Standalone集群将使用spark.deploy.defaultCores中数值，而Mesos将使用集群中可用的内核</td>
</tr>
<tr>
<td>spark.mesos.coarse</td>
<td>False</td>
<td>如果设置为true，在Mesos集群中运行时使用粗粒度共享模式</td>
</tr>
<tr>
<td>spark.speculation</td>
<td>False</td>
<td>以下几个参数是关于Spark推测执行机制的相关参数。此参数设定是否使用推测执行机制，如果设置为true则spark使用推测执行机制，对于Stage中拖后腿的Task在其他节点中重新启动，并将最先完成的Task的计算结果最为最终结果</td>
</tr>
<tr>
<td>spark.speculation.interval</td>
<td>100</td>
<td>Spark多长时间进行检查task运行状态用以推测，以毫秒为单位</td>
</tr>
<tr>
<td>spark.speculation.quantile</td>
<td></td>
<td>推测启动前，Stage必须要完成总Task的百分比</td>
</tr>
<tr>
<td>spark.speculation.multiplier</td>
<td>1.5</td>
<td>比已完成Task的运行速度中位数慢多少倍才启用推测</td>
</tr>
<tr>
<td>spark.locality.wait</td>
<td>3000</td>
<td>以下几个参数是关于Spark数据本地性的。本参数是以毫秒为单位启动本地数据task的等待时间，如果超出就启动下一本地优先级别的task。该设置同样可以应用到各优先级别的本地性之间（本地进程 -&gt; 本地节点 -&gt; 本地机架 -&gt; 任意节点 ），当然，也可以通过spark.locality.wait.node等参数设置不同优先级别的本地性</td>
</tr>
<tr>
<td>spark.locality.wait.process</td>
<td>spark.locality.wait</td>
<td>本地进程级别的本地等待时间</td>
</tr>
<tr>
<td>spark.locality.wait.node</td>
<td>spark.locality.wait</td>
<td>本地节点级别的本地等待时间</td>
</tr>
<tr>
<td>spark.locality.wait.rack</td>
<td>spark.locality.wait</td>
<td>本地机架级别的本地等待时间</td>
</tr>
<tr>
<td>spark.scheduler.revive.interval</td>
<td>1000</td>
<td>复活重新获取资源的Task的最长时间间隔（毫秒），发生在Task因为本地资源不足而将资源分配给其他Task运行后进入等待时间，如果这个等待时间内重新获取足够的资源就继续计算</td>
</tr>
</tbody></table>
<h3 id="Dynamic-Allocation"><a href="#Dynamic-Allocation" class="headerlink" title="Dynamic Allocation"></a>Dynamic Allocation</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.dynamicAllocation.enabled</td>
<td>false</td>
<td>是否开启动态资源搜集</td>
</tr>
<tr>
<td>spark.dynamicAllocation.executorIdleTimeout</td>
<td>600</td>
<td></td>
</tr>
<tr>
<td>spark.dynamicAllocation.initialExecutors</td>
<td>spark.dynamicAllocation.minExecutors</td>
<td></td>
</tr>
<tr>
<td>spark.dynamicAllocation.maxExecutors</td>
<td>Integer.MAX_VALUE</td>
<td></td>
</tr>
<tr>
<td>spark.dynamicAllocation.minExecutors</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>spark.dynamicAllocation.schedulerBacklogTimeout</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>spark.dynamicAllocation.sustainedSchedulerBacklogTimeout</td>
<td>schedulerBacklogTimeout</td>
<td></td>
</tr>
</tbody></table>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.authenticate</td>
<td>false</td>
<td>是否Spark验证其内部连接。如果不是运行在YARN上，请看<code>spark.authenticate.secret</code></td>
</tr>
<tr>
<td>spark.authenticate.secret</td>
<td>None</td>
<td>设置Spark两个组件之间的密匙验证。如果不是运行在YARN上，但是需要验证，这个选项必须设置</td>
</tr>
<tr>
<td>spark.core.connection.auth.wait.timeout</td>
<td>30</td>
<td>连接时等待验证的实际。单位为秒</td>
</tr>
<tr>
<td>spark.core.connection.ack.wait.timeout</td>
<td>60</td>
<td>连接等待回答的时间。单位为秒。为了避免不希望的超时，你可以设置更大的值</td>
</tr>
<tr>
<td>spark.ui.filters</td>
<td>None</td>
<td>应用到Spark web UI的用于过滤类名的逗号分隔的列表。过滤器必须是标准的<a href="http://docs.oracle.com/javaee/6/api/javax/servlet/Filter.html" target="_blank" rel="noopener">javax servlet Filter</a>。通过设置java系统属性也可以指定每个过滤器的参数。<code>spark.&lt;class name of filter&gt;.params=&#39;param1=value1,param2=value2&#39;</code>。例如<code>-Dspark.ui.filters=com.test.filter1</code>、<code>-Dspark.com.test.filter1.params=&#39;param1=foo,param2=testing&#39;</code></td>
</tr>
<tr>
<td>spark.acls.enable</td>
<td>false</td>
<td>是否开启Spark acls。如果开启了，它检查用户是否有权限去查看或修改job。UI利用使用过滤器验证和设置用户</td>
</tr>
<tr>
<td>spark.ui.view.acls</td>
<td>empty</td>
<td>逗号分隔的用户列表，列表中的用户有查看Spark web UI的权限。默认情况下，只有启动Spark job的用户有查看权限</td>
</tr>
<tr>
<td>spark.modify.acls</td>
<td>empty</td>
<td>逗号分隔的用户列表，列表中的用户有修改Spark job的权限。默认情况下，只有启动Spark job的用户有修改权限</td>
</tr>
<tr>
<td>spark.admin.acls</td>
<td>empty</td>
<td>逗号分隔的用户或者管理员列表，列表中的用户或管理员有查看和修改所有Spark job的权限。如果你运行在一个共享集群，有一组管理员或开发者帮助debug，这个选项有用</td>
</tr>
</tbody></table>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.ssl.enabled</td>
<td>false</td>
<td>是否开启ssl</td>
</tr>
<tr>
<td>spark.ssl.enabledAlgorithms</td>
<td>Empty</td>
<td>JVM支持的加密算法列表，逗号分隔</td>
</tr>
<tr>
<td>spark.ssl.keyPassword</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>spark.ssl.keyStore</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>spark.ssl.keyStorePassword</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>spark.ssl.protocol</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>spark.ssl.trustStore</td>
<td>None</td>
<td></td>
</tr>
<tr>
<td>spark.ssl.trustStorePassword</td>
<td>None</td>
<td></td>
</tr>
</tbody></table>
<h3 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h3><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.streaming.blockInterval</td>
<td>200</td>
<td>在这个时间间隔（ms）内，通过Spark Streaming receivers接收的数据在保存到Spark之前，chunk为数据块。推荐的最小值为50ms</td>
</tr>
<tr>
<td>spark.streaming.receiver.maxRate</td>
<td>infinite</td>
<td>每秒钟每个receiver将接收的数据的最大记录数。有效的情况下，每个流将消耗至少这个数目的记录。设置这个配置为0或者-1将会不作限制</td>
</tr>
<tr>
<td>spark.streaming.receiver.writeAheadLogs.enable</td>
<td>false</td>
<td>Enable write ahead logs for receivers. All the input data received through receivers will be saved to write ahead logs that will allow it to be recovered after driver failures</td>
</tr>
<tr>
<td>spark.streaming.unpersist</td>
<td>true</td>
<td>强制通过Spark Streaming生成并持久化的RDD自动从Spark内存中非持久化。通过Spark Streaming接收的原始输入数据也将清除。设置这个属性为false允许流应用程序访问原始数据和持久化RDD，因为它们没有被自动清除。但是它会造成更高的内存花费</td>
</tr>
</tbody></table>
<h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><h4 id="Spark-On-YARN"><a href="#Spark-On-YARN" class="headerlink" title="Spark On YARN"></a>Spark On YARN</h4><table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>spark.yarn.am.memory</td>
<td>512m</td>
<td>client 模式时，am的内存大小；cluster模式时，使用<code>spark.driver.memory</code>变量</td>
</tr>
<tr>
<td>spark.driver.cores</td>
<td>1</td>
<td>claster模式时，driver使用的cpu核数，这时候driver运行在am中，其实也就是am和核数；client模式时，使用<code>spark.yarn.am.cores</code>变量</td>
</tr>
<tr>
<td>spark.yarn.am.cores</td>
<td>1</td>
<td>client 模式时，am的cpu核数</td>
</tr>
<tr>
<td>spark.yarn.am.waitTime</td>
<td>100000</td>
<td>启动时等待时间</td>
</tr>
<tr>
<td>spark.yarn.submit.file.replication</td>
<td>3</td>
<td>应用程序上传到HDFS的文件的副本数</td>
</tr>
<tr>
<td>spark.yarn.preserve.staging.files</td>
<td>False</td>
<td>若为true，在job结束后，将stage相关的文件保留而不是删除</td>
</tr>
<tr>
<td>spark.yarn.scheduler.heartbeat.interval-ms</td>
<td>5000</td>
<td>Spark AppMaster发送心跳信息给YARN RM的时间间隔</td>
</tr>
<tr>
<td>spark.yarn.max.executor.failures</td>
<td>2倍于executor数，最小值3</td>
<td>导致应用程序宣告失败的最大executor失败次数</td>
</tr>
<tr>
<td>spark.yarn.applicationMaster.waitTries</td>
<td>10</td>
<td>RM等待Spark AppMaster启动重试次数，也就是SparkContext初始化次数。超过这个数值，启动失败</td>
</tr>
<tr>
<td>spark.yarn.historyServer.address</td>
<td></td>
<td>Spark history server的地址（不要加 <code>http://</code>）。这个地址会在Spark应用程序完成后提交给YARN RM，然后RM将信息从RM UI写到history server UI上。</td>
</tr>
<tr>
<td>spark.yarn.dist.archives</td>
<td>(none)</td>
<td></td>
</tr>
<tr>
<td>spark.yarn.dist.files</td>
<td>(none)</td>
<td></td>
</tr>
<tr>
<td>spark.executor.instances</td>
<td>2</td>
<td>executor实例个数</td>
</tr>
<tr>
<td>spark.yarn.executor.memoryOverhead</td>
<td>executorMemory * 0.07, with minimum of 384</td>
<td>executor的堆内存大小设置</td>
</tr>
<tr>
<td>spark.yarn.driver.memoryOverhead</td>
<td>driverMemory * 0.07, with minimum of 384</td>
<td>driver的堆内存大小设置</td>
</tr>
<tr>
<td>spark.yarn.am.memoryOverhead</td>
<td>AM memory * 0.07, with minimum of 384</td>
<td>am的堆内存大小设置，在client模式时设置</td>
</tr>
<tr>
<td>spark.yarn.queue</td>
<td>default</td>
<td>使用yarn的队列</td>
</tr>
<tr>
<td>spark.yarn.jar</td>
<td>(none)</td>
<td></td>
</tr>
<tr>
<td>spark.yarn.access.namenodes</td>
<td>(none)</td>
<td></td>
</tr>
<tr>
<td>spark.yarn.appMasterEnv.[EnvironmentVariableName]</td>
<td>(none)</td>
<td>设置am的环境变量</td>
</tr>
<tr>
<td>spark.yarn.containerLauncherMaxThreads</td>
<td>25</td>
<td>am启动executor的最大线程数</td>
</tr>
<tr>
<td>spark.yarn.am.extraJavaOptions</td>
<td>(none)</td>
<td></td>
</tr>
<tr>
<td>spark.yarn.maxAppAttempts</td>
<td>yarn.resourcemanager.am.max-attempts in YARN</td>
<td>am重试次数</td>
</tr>
</tbody></table>
<h3 id="Spark-on-Mesos"><a href="#Spark-on-Mesos" class="headerlink" title="Spark on Mesos"></a>Spark on Mesos</h3><p>使用较少，参考<a href="https:/.apache.org/docs/latest/running-on-mesos.html#configuration" target="_blank" rel="noopener">Running Spark on Mesos</a>。</p>
<h3 id="Spark-Standalone-Mode"><a href="#Spark-Standalone-Mode" class="headerlink" title="Spark Standalone Mode"></a>Spark Standalone Mode</h3><p>参考<a href="https:/.apache.org/docs/latest-standalone.html#cluster-launch-scripts" target="_blank" rel="noopener">Spark Standalone Mode</a>。</p>
<h3 id="Spark-History-Server"><a href="#Spark-History-Server" class="headerlink" title="Spark History Server"></a>Spark History Server</h3><p>当你运行Spark Standalone Mode或者Spark on Mesos模式时，你可以通过Spark History Server来查看job运行情况。</p>
<p>Spark History Server的环境变量：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SPARK_DAEMON_MEMORY</td>
<td>Memory to allocate to the history server (default: 512m).</td>
</tr>
<tr>
<td>SPARK_DAEMON_JAVA_OPTS</td>
<td>JVM options for the history server (default: none).</td>
</tr>
<tr>
<td>SPARK_PUBLIC_DNS</td>
<td></td>
</tr>
<tr>
<td>SPARK_HISTORY_OPTS</td>
<td>配置 spark.history.* 属性</td>
</tr>
</tbody></table>
<p>Spark History Server的属性：</p>
<table>
<thead>
<tr>
<th align="left">属性名称</th>
<th align="left">默认</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">spark.history.provider</td>
<td align="left">org.apache.spark.deploy.history.FsHistoryProvide</td>
<td align="left">应用历史后端实现的类名。 目前只有一个实现, 由Spark提供, 它查看存储在文件系统里面的应用日志</td>
</tr>
<tr>
<td align="left">spark.history.fs.logDirectory</td>
<td align="left">file:/tmp-events</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">spark.history.updateInterval</td>
<td align="left">10</td>
<td align="left">以秒为单位，多长时间Spark history server显示的信息进行更新。每次更新都会检查持久层事件日志的任何变化。</td>
</tr>
<tr>
<td align="left">spark.history.retainedApplications</td>
<td align="left">50</td>
<td align="left">在Spark history server上显示的最大应用程序数量，如果超过这个值，旧的应用程序信息将被删除。</td>
</tr>
<tr>
<td align="left">spark.history.ui.port</td>
<td align="left">18080</td>
<td align="left">官方版本中，Spark history server的默认访问端口</td>
</tr>
<tr>
<td align="left">spark.history.kerberos.enabled</td>
<td align="left">false</td>
<td align="left">是否使用kerberos方式登录访问history server，对于持久层位于安全集群的HDFS上是有用的。如果设置为true，就要配置下面的两个属性。</td>
</tr>
<tr>
<td align="left">spark.history.kerberos.principal</td>
<td align="left">空</td>
<td align="left">用于Spark history server的kerberos主体名称</td>
</tr>
<tr>
<td align="left">spark.history.kerberos.keytab</td>
<td align="left">空</td>
<td align="left">用于Spark history server的kerberos keytab文件位置</td>
</tr>
<tr>
<td align="left">spark.history.ui.acls.enable</td>
<td align="left">false</td>
<td align="left">授权用户查看应用程序信息的时候是否检查acl。如果启用，只有应用程序所有者和<code>spark.ui.view.acls</code>指定的用户可以查看应用程序信息;如果禁用，不做任何检查。</td>
</tr>
</tbody></table>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>通过环境变量配置确定的Spark设置。环境变量从Spark安装目录下的<code>conf-env.sh</code>脚本读取（或者windows的<code>conf-env.cmd</code>）。在独立的或者Mesos模式下，这个文件可以给机器确定的信息，如主机名。当运行本地应用程序或者提交脚本时，它也起作用。</p>
<p>注意，当Spark安装时，<code>conf-env.sh</code>默认是不存在的。你可以复制<code>conf-env.sh.template</code>创建它。</p>
<p>可以在<code>spark-env.sh</code>中设置如下变量：</p>
<table>
<thead>
<tr>
<th>环境变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>JAVA_HOME</td>
<td>Java安装的路径</td>
</tr>
<tr>
<td>PYSPARK_PYTHON</td>
<td>PySpark用到的Python二进制执行文件路径</td>
</tr>
<tr>
<td>SPARK_LOCAL_IP</td>
<td>机器绑定的IP地址</td>
</tr>
<tr>
<td>SPARK_PUBLIC_DNS</td>
<td>你Spark应用程序通知给其他机器的主机名</td>
</tr>
</tbody></table>
<p>除了以上这些，Spark <a href="http:/.apache.org/docs/latest-standalone.html#cluster-launch-scripts" target="_blank" rel="noopener">standalone cluster scripts</a>也可以设置一些选项。例如每台机器使用的核数以及最大内存。</p>
<p>因为<code>spark-env.sh</code>是shell脚本，其中的一些可以以编程方式设置。例如，你可以通过特定的网络接口计算<code>SPARK_LOCAL_IP</code>。</p>
<h2 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h2><p>Spark用<a href="http://logging.apache.org/log4j/" target="_blank" rel="noopener">log4j</a> logging。你可以通过在conf目录下添加<code>log4j.properties</code>文件来配置。一种方法是复制<code>log4j.properties.template</code>文件。</p>

      
    </div>

    

    
    
    


    
      <div>
        




  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>JavaChen</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="http://javachen.github.io/2015/06/07/spark-configuration/" title="Spark配置参数">Spark配置参数</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="JavaChen 微信支付">
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="JavaChen 支付宝">
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    



    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/spark/" rel="tag"><i class="fa fa-tag"></i> spark</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
            
              <div>
                
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

              </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/06/05/yarn-memory-and-cpu-configuration/" rel="next" title="YARN的内存和CPU配置">
                <i class="fa fa-chevron-left"></i> YARN的内存和CPU配置
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/06/09/memory-in-spark-on-yarn/" rel="prev" title="Spark On YARN内存分配">
                Spark On YARN内存分配 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2009 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JavaChen</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').not('.gist .highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      const selection = document.getSelection();
      const selected = selection.rangeCount > 0 ? selection.getRangeAt(0) : false;
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
      ta.blur(); // For iOS
      $(this).blur();
      if (selected) {
        selection.removeAllRanges();
        selection.addRange(selected);
      }
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
