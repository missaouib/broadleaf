<!DOCTYPE html>




<html class="theme-next mist" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Arial:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="bash,">





  <link rel="alternate" href="/atom.xml" title="JavaChen Blog" type="application/atom+xml">






<meta name="description" content="本文根据《Advanced Bash Scripting Guide》这本书整理而来。Bash中，用在脚本和其他地方的字符叫做特殊字符。">
<meta name="keywords" content="bash">
<meta property="og:type" content="article">
<meta property="og:title" content="Bash中的特殊字符">
<meta property="og:url" content="http://blog.javachen.com/2015/07/06/bash-special-characters/index.html">
<meta property="og:site_name" content="JavaChen Blog">
<meta property="og:description" content="本文根据《Advanced Bash Scripting Guide》这本书整理而来。Bash中，用在脚本和其他地方的字符叫做特殊字符。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-03-26T08:41:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bash中的特殊字符">
<meta name="twitter:description" content="本文根据《Advanced Bash Scripting Guide》这本书整理而来。Bash中，用在脚本和其他地方的字符叫做特殊字符。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"remove","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.javachen.com/2015/07/06/bash-special-characters/">





  <title>Bash中的特殊字符 | JavaChen Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?50bc6f5d9b045b5895ff44f8bbdbc611";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JavaChen Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Ramblings of a coder</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.javachen.com/2015/07/06/bash-special-characters/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JavaChen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JavaChen Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Bash中的特殊字符</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-06T00:00:00+08:00">
                2015-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/devops/" itemprop="url" rel="index">
                    <span itemprop="name">devops</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          <!--/删除
          
              <div class="post-description">
                  本文根据《Advanced Bash Scripting Guide》这本书整理而来。Bash中，用在脚本和其他地方的字符叫做特殊字符。
              </div>
          
          -->
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Bash中，用在脚本和其他地方的字符叫做特殊字符。下面依次举例介绍每个字符的用途。</p>
<h2 id><a href="#" class="headerlink" title="#"></a><code>#</code></h2><p>行首以<code>#</code>(<code>#!</code>是个例外)开头是注释。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This line is a comment.</span></span><br></pre></td></tr></table></figure>

<p>注释也可以放在于本行命令的后边。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"A comment will follow."</span>   <span class="comment"># 注释在这里。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令是不能放在同一行上注释的后边的。因为没有办法把注释结束掉，好让同一行上后边的”代码生效”，只能够另起一行来使用下一个命令。</p>
</blockquote>
<p>在echo中转义的<code>#</code>是不能作为注释的，同样也可以出现在特定的参数替换结构中，或者是出现在数字常量表达式中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"The # here does not begin a comment."</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">'The # here does not begin a comment.'</span> </span><br><span class="line"><span class="built_in">echo</span> The \<span class="comment"># here does not begin a comment.    #转义字符\</span></span><br><span class="line"><span class="built_in">echo</span> The <span class="comment"># 这里开始一个注释.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH#*:&#125;</span>   <span class="comment"># 参数替换, 不是一个注释</span></span><br><span class="line"><span class="built_in">echo</span> $(( 2<span class="comment">#101011 ))   # 数制转换, 不是一个注释</span></span><br></pre></td></tr></table></figure>

<p>标准的引用和转义字符<code>&quot; &#39; \</code>可以用来转义<code>#</code>，某些特定的模式匹配操作也可以使用<code>#</code>。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=";"></a><code>;</code></h2><p>分号作为命令行分隔符，可以在同一行上写两个或两个以上的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello; <span class="built_in">echo</span> there</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -x <span class="string">"<span class="variable">$filename</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"File <span class="variable">$filename</span> exists."</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"File <span class="variable">$filename</span> not found."</span>; touch <span class="variable">$filename</span> </span><br><span class="line"><span class="keyword">fi</span>; <span class="built_in">echo</span> <span class="string">"File test complete."</span></span><br></pre></td></tr></table></figure>

<p>在某些情况下，<code>;</code>也可以被转义。</p>
<h2 id="-2"><a href="#-2" class="headerlink" title=";;"></a><code>;;</code></h2><p>终止case选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$variable</span>"</span> <span class="keyword">in</span></span><br><span class="line">    abc) <span class="built_in">echo</span> <span class="string">"\$variable = abc"</span> ;; </span><br><span class="line">    xyz) <span class="built_in">echo</span> <span class="string">"\$variable = xyz"</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h2 id="-3"><a href="#-3" class="headerlink" title="."></a><code>.</code></h2><p>点命令等价于<code>source</code>命令，这是一个bash的内建命令。</p>
<p>如果点放在文件名的开头的话，那么这个文件将会成为”隐藏”文件，并且<code>ls</code>命令将不会正常的显示出这个文件。</p>
<p>如果作为目录名的话，一个单独的点代表当前的工作目录，而两个点表示上一级目录。</p>
<p>点也可以表示当前目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /home/javachen/current_work/* .</span><br></pre></td></tr></table></figure>

<p>当用作匹配字符的作用时，通常都是作为正则表达式的一部分来使用，点用来匹配任何的单个字符。</p>
<h2 id="quot-39"><a href="#quot-39" class="headerlink" title="&quot;,&#39;"></a><code>&quot;</code>,<code>&#39;</code></h2><p>双引号为部分引用，单引号为全引用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"The # here does not begin a comment."</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">'The # here does not begin a comment.'</span></span><br></pre></td></tr></table></figure>

<h2 id="-4"><a href="#-4" class="headerlink" title=","></a><code>,</code></h2><p>逗号操作费，链接了一系列的算术操作。 虽然里边所有的内容都被运行了，但只有最后一项被返回。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="string">"t2 = ((a = 9, 15 / 3))"</span> <span class="comment"># a = 9   t2 = 15 / 3</span></span><br></pre></td></tr></table></figure>

<p>也可以这样使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#123;a,b,c&#125;  <span class="comment">#创建三个目录a、b、c</span></span><br></pre></td></tr></table></figure>

<h2 id="-5"><a href="#-5" class="headerlink" title="\"></a><code>\</code></h2><p>转义符，一种对单字符的引用机制，通常是用于对单字符进行转义。<code>\</code>通常用来转义<code>&quot;</code>和<code>&#39;</code>，这样双引号和但引号就不会被解释成特殊含义了。</p>
<h2 id="-6"><a href="#-6" class="headerlink" title="/"></a><code>/</code></h2><p>文件名路径分隔符，分隔文件名不同的部分，也可以用来作为除法算术操作符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/bozo/projects/Makefile</span><br><span class="line"><span class="built_in">let</span> <span class="string">"t2 = ((a = 9, 15 / 3))"</span> <span class="comment"># a = 9   t2 = 15 / 3</span></span><br></pre></td></tr></table></figure>

<h2 id="-7"><a href="#-7" class="headerlink" title="`"></a>`</h2><p>命令替换，<code>command</code>结构可以将命令的输出赋值到一个变量中去。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date=`date`</span><br></pre></td></tr></table></figure>

<h2 id="-8"><a href="#-8" class="headerlink" title=":"></a><code>:</code></h2><p>空命令，等价于”NOP”，什么都不做，也可以被认为与shell的内建命令true作用相同。”:”命令是一个bash的内建命令，它的退出码是”true”，即为0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:</span><br><span class="line"><span class="built_in">echo</span> $? <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<p>死循环：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :   <span class="comment"># while true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    date</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>在 if/then 中的占位符，什么都不做，引出分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span> :          <span class="comment"># 什么都不做，引出分支</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    take-some-action</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在一个二元命令中提供一个占位符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=1</span><br><span class="line">: $((n = <span class="variable">$n</span> + 1))  <span class="comment"># 如果没有":"的话，Bash 将会尝试把 $((n = $n + 1)) 解释为一个命令，运行时会报错</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"<span class="variable">$n</span> "</span></span><br></pre></td></tr></table></figure>

<p>在here document中提供一个命令所需的占位符或者用于注释代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">: &lt;&lt;TESTVARIABLES</span><br><span class="line"><span class="variable">$&#123;HOSTNAME?&#125;</span><span class="variable">$&#123;USER?&#125;</span><span class="variable">$&#123;MAIL?&#125;</span> <span class="comment"># 如果其中某个变量没被设置, 那么就打印错误信息. </span></span><br><span class="line">TESTVARIABLES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">: &lt;&lt;COMMENTBLOCK</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"This line will not echo."</span></span><br><span class="line">This is a comment line missing the <span class="string">"#"</span> prefix.</span><br><span class="line">This is another comment line missing the <span class="string">"#"</span> prefix.</span><br><span class="line">&amp;*@!!++=</span><br><span class="line">The above line will cause no error message,</span><br><span class="line">because the Bash interpreter will ignore it.</span><br><span class="line">COMMENTBLOCK</span><br></pre></td></tr></table></figure>

<p>使用参数替换来评估字符串变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: <span class="variable">$&#123;HOSTNAME ?&#125;</span> <span class="variable">$&#123;USER?&#125;</span> <span class="variable">$&#123;MAIL?&#125;</span>  <span class="comment">#如果一个或多个必要的环境变量没被设置的话，就打印错误信息.</span></span><br></pre></td></tr></table></figure>

<p>在与<code>&gt;</code>重定向操作符结合使用时，将会把一个文件清空，但是并不会修改这个文件的权限。如果之前这个文件并不存在，那么就创建这个文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">: &gt; data.xxx  <span class="comment"># 文件"data.xxx" 现在被清空了</span></span><br><span class="line"><span class="comment"># 与 cat /dev/null &gt;data.xxx 的作用相同</span></span><br><span class="line"><span class="comment"># 然而，这并不会产生一个新的进程，因为":"是一个内建命令</span></span><br></pre></td></tr></table></figure>

<p>在与<code>&gt;&gt;</code>重定向操作符结合使用时，将不会对预先存在的目标文件产生任何影响。如果这个文件之前并不存在，那么就创建它。<code>这只适用于正规文件,，而不适用于管道、符号连接和某些特殊文件</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: &gt;&gt; target_file</span><br></pre></td></tr></table></figure>

<p>也可能用来作为注释行，虽然我们不推荐这么做。使用#来注释的话，将关闭剩余行的错误检查，所以可以在注释行中写任何东西。然而，使用:的话将不会这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: This is a comment that generates an error, ( <span class="keyword">if</span> [ <span class="variable">$x</span> -eq 3] <span class="keyword">fi</span> ).</span><br></pre></td></tr></table></figure>

<p>“:”还用来在/etc/passwd和<code>$PATH</code>变量中做分隔符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/java/default/bin:/usr/lib64/qt-3.3/bin:/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>

<h2 id="-9"><a href="#-9" class="headerlink" title="!"></a><code>!</code></h2><p>取反操作符。<code>!</code>操作符将会反转命令的退出码的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span>        <span class="comment"># "true" 是内建命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"exit status of \"true\" = $?"</span>         <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">! <span class="literal">true</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"exit status of \"! true\" = $?"</span>       <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>如果一个命令以<code>!</code>开头，那么会启用Bash的历史机制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line">!<span class="literal">true</span></span><br><span class="line"><span class="comment"># 这次就没有错误了, 也没有反转结果.它只是重复了之前的命令(true).</span></span><br></pre></td></tr></table></figure>

<p>在另一种上下文中，如命令行模式下，<code>!</code>还能反转bash的历史机制。需要注意 的是，在一个脚本中，历史机制是被禁用的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">history</span> |head -n 10</span><br><span class="line">   18  date</span><br><span class="line">   19  ls</span><br><span class="line">   20  <span class="built_in">cd</span></span><br><span class="line">   21  <span class="built_in">pwd</span></span><br><span class="line">   22  jps</span><br><span class="line">   23  java</span><br><span class="line">   24  ll</span><br><span class="line">   25  ps</span><br><span class="line">   26  <span class="built_in">history</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行bash历史中的一条命令</span></span><br><span class="line">$ !25</span><br></pre></td></tr></table></figure>

<p><code>!</code>操作符还是Bash的关键字。</p>
<p>在一个不同的上下文中，<code>!</code>也会出现在变量的<code>间接引用</code>中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a=letter_of_alphabet</span><br><span class="line">letter_of_alphabet=z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接引用.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a = <span class="variable">$a</span>"</span>   <span class="comment"># a = letter_of_alphabet</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 间接引用.</span></span><br><span class="line"><span class="built_in">eval</span> a=\$<span class="variable">$a</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Now a=<span class="variable">$a</span>"</span>    <span class="comment">#Now a = z</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 间接引用.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!a&#125;</span>  <span class="comment"># a = z</span></span><br></pre></td></tr></table></figure>

<h2 id="-10"><a href="#-10" class="headerlink" title="*"></a><code>*</code></h2><p>用来做文件名匹配：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> *</span><br><span class="line">abs-book.sgml add-drive.sh agram.sh alias.sh</span><br></pre></td></tr></table></figure>

<p>也可以用在正则表达式中，用来匹配任意个数(包含0个)的字符。</p>
<p>在算术操作符的上下文中， <code>*</code>号表示乘法运算。如果要做幂运算，使用<code>**</code>，这是求幂操作符。</p>
<h2 id="？"><a href="#？" class="headerlink" title="？"></a><code>？</code></h2><p>测试操作符。在一个特定的表达式中，<code>?</code>用来测试一个条件的结果。</p>
<p>在一个双括号结构中，<code>?</code>就是C语言的三元操作符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( t = a&lt;45?7:11 )) <span class="comment"># C语言风格的三元操作</span></span><br></pre></td></tr></table></figure>

<p>在参数替换表达式中，<code>?</code>用来测试一个变量是否set。</p>
<p>在通配中，用来做匹配单个字符的”通配符”，在正则表达式中，也是用来表示一个字符。</p>
<h2 id="-11"><a href="#-11" class="headerlink" title="$"></a><code>$</code></h2><p>在<code>变量替换</code>中，用于引用变量的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1=5</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var1</span></span><br></pre></td></tr></table></figure>

<p>在一个变量前面加上<code>$</code>用来引用这个变量的值。</p>
<p> 在正则表达式中，表示行结束符。</p>
<p> <code>${}</code> 是参数替换，<code>$*</code>, <code>$@</code>是位置参数，<code>$?</code> 是退出状态码变量，<code>$$</code>是进程id变量，保存所在脚本的进程 ID。</p>
<h2 id="-12"><a href="#-12" class="headerlink" title="()"></a><code>()</code></h2><p>命令组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a=hello; <span class="built_in">echo</span> <span class="variable">$a</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在括号中的命令列表，将会作为一个子shell来运行。</p>
</blockquote>
<p>例外: 在pipe中的一个大括号中的代码段可能运行在一个 子shell中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls | &#123; <span class="built_in">read</span> firstline; <span class="built_in">read</span> secondline; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#错误. 在大括号中的代码段, 将运行到子shell中, 所以"ls"的输出将不能传递到代码块中</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"First line is <span class="variable">$firstline</span>; second line is <span class="variable">$secondline</span>"</span>  <span class="comment"># 不能工作</span></span><br></pre></td></tr></table></figure>

<p>初始化数组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array=(element1 element2 element3)</span><br></pre></td></tr></table></figure>

<h2 id="xxx-yyy-zzz"><a href="#xxx-yyy-zzz" class="headerlink" title="{xxx,yyy,zzz,...}"></a><code>{xxx,yyy,zzz,...}</code></h2><p>大括号扩展：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &#123;file1,file2,file3&#125; &gt; combined_file</span><br><span class="line"></span><br><span class="line">cp file22.&#123;txt,backup&#125; <span class="comment"># 拷贝"file22.txt"到"file22.backup"中</span></span><br></pre></td></tr></table></figure>

<p>一个命令可能会对大括号中的以逗号分的文件列表起作用。在通配符中，将对大括号中的文件名做扩展。</p>
<p>在大括号中，不允许有空白，除非这个空白引用或转义。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;file1,file2&#125;\ :&#123;\ A,<span class="string">" B"</span>,<span class="string">' C'</span>&#125;</span><br><span class="line">file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C</span><br></pre></td></tr></table></figure>

<h2 id="-13"><a href="#-13" class="headerlink" title="{}"></a><code>{}</code></h2><p>代码块，又被称为内部组，这个结构事实上创建一个匿名函数。与”标准”函数不同的是，在其中的变量，对于脚本其他部分的代码来还是可见的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="built_in">local</span> a; a=1; &#125;</span><br><span class="line">-bash: <span class="built_in">local</span>: can only be used <span class="keyword">in</span> a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=123</span><br><span class="line">&#123; a=321; &#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"a = <span class="variable">$a</span>"</span>  <span class="comment"># a = 321 (说明在代码块中对变量a所作的修改影响了外边的变量)</span></span><br></pre></td></tr></table></figure>

<p>下边的代码展示在大括号结构中代码的I/O 重定向。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 从/etc/fstab中读行. 3</span></span><br><span class="line">File=/etc/fstab</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">read</span> line1</span><br><span class="line"> <span class="built_in">read</span> line2</span><br><span class="line">&#125; &lt; <span class="variable">$File</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"First line in <span class="variable">$File</span> is:"</span> <span class="string">"<span class="variable">$line1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Second line in <span class="variable">$File</span> is:"</span> <span class="string">"<span class="variable">$line2</span>"</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>与上面所讲到的<code>()</code>中的命令组不同的是，大括号中的代码块将不会开一个新的子shell。</p>
<h2 id="39-39"><a href="#39-39" class="headerlink" title="&#39;{}&#39; \;"></a><code>&#39;{}&#39; \;</code></h2><p>路径名。一般都在<code>find</code>命令中使用，这不是一个shell内建命令。<code>;</code>用来结束find命令序列的<code>-exec</code>选项，它需要被保护以防止被shell所解释。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -mtime -1 -<span class="built_in">type</span> f -<span class="built_in">exec</span> tar rvf archive.tar <span class="string">'&#123;&#125;'</span> \;</span><br></pre></td></tr></table></figure>

<h2 id="-14"><a href="#-14" class="headerlink" title="[]"></a><code>[]</code></h2><p>条件测试。</p>
<p>在一个array结构的上下文中，中括号用来引用数组中每个元素的编号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array[1]=a </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;Array[1]&#125;</span></span><br></pre></td></tr></table></figure>

<p>用作正则表达式的一部分，方括号描一个匹配的字符范围。例如，正则表达式中，”[xyz]” 将会匹配字符x, y, 或z。</p>
<h2 id="-15"><a href="#-15" class="headerlink" title="[[ ]]"></a><code>[[ ]]</code></h2><p>测试表达式在<code>[[ ]]</code>中。</p>
<h2 id="-16"><a href="#-16" class="headerlink" title="(( ))"></a><code>(( ))</code></h2><p>双圆括号结构，扩展并计算在<code>(( ))</code>中的整数表达式。</p>
<p>与let命令很相似，(<code>(...))</code>结构允许算术扩展和赋值。举个简单的例子，<code>a=$(( 5 + 3 ))</code>，将把变量”a”设为”5 + 3”或者8。 </p>
<h2 id="gt-amp-gt-gt-amp-gt-gt-lt-lt-gt"><a href="#gt-amp-gt-gt-amp-gt-gt-lt-lt-gt" class="headerlink" title="&gt; &amp;&gt; &gt;&amp; &gt;&gt; &lt; &lt;&gt;"></a><code>&gt;</code> <code>&amp;&gt;</code> <code>&gt;&amp;</code> <code>&gt;&gt;</code> <code>&lt;</code> <code>&lt;&gt;</code></h2><p>重定向。</p>
<p>重定向scriptname的输出到文件filename中。如果filename存在的，那么将会被覆盖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scriptname &gt;filename</span><br></pre></td></tr></table></figure>

<p>也可以清空文件内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; a.log</span><br></pre></td></tr></table></figure>

<p>重定向command的stdout和stderr到filename中:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &amp;&gt;filename</span><br></pre></td></tr></table></figure>

<p>重定向command的stdout到stderr中:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt;&amp;2</span><br></pre></td></tr></table></figure>

<p>把scriptname的输出加到文件filename中。如果filename不存在的话，将被创建。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scriptname &gt;&gt; filename</span><br></pre></td></tr></table></figure>

<p>打开文件filename用来读写，并且分配文件描述符i给这个文件。如果filename不存在，这个文件将会创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[i]&lt;&gt;filename</span><br></pre></td></tr></table></figure>

<p>“&lt;”或”&gt;”还可以用于<code>进程替换</code>。</p>
<p>在一种不同的上下文中，”&lt;”和”&gt;”可用来做字符串比较操作或者整数比较。</p>
<h2 id="lt-lt"><a href="#lt-lt" class="headerlink" title="&lt;&lt;"></a><code>&lt;&lt;</code></h2><p>用在here document中的重定向。</p>
<h2 id="lt-lt-lt"><a href="#lt-lt-lt" class="headerlink" title="&lt;&lt;&lt;"></a><code>&lt;&lt;&lt;</code></h2><p>用在here string中的重定向。</p>
<h2 id="lt-gt"><a href="#lt-gt" class="headerlink" title="\&lt;,\&gt;"></a><code>\&lt;</code>,<code>\&gt;</code></h2><p>正则表达式中的单词边：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'\&lt;the\&gt;'</span> textfile</span><br></pre></td></tr></table></figure>

<h2 id="-17"><a href="#-17" class="headerlink" title="|"></a><code>|</code></h2><p>管道。分析前边命令的输出，并将输出作为后边命令的输入。这是一种产生命令链的好方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与一个简单的"ls -l"结果相同</span></span><br><span class="line"><span class="built_in">echo</span> ls -l | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并和排序所有的".lst"文件, 然后删除所有重复的行.</span></span><br><span class="line">cat *.lst | sort | uniq</span><br></pre></td></tr></table></figure>

<p>输出的命令也可以传递到脚本中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># uppercase.sh : 修改输入, 全部转换为大写</span></span><br><span class="line"></span><br><span class="line">tr <span class="string">'a-z'</span> <span class="string">'A-Z'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>现在我们输送<code>ls -l</code>的输出到该脚本中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l | ./uppercase.sh</span><br><span class="line">DRWXR-X--- 2 ROOT ROOT      4096 05-28 10:06 ML-1M</span><br><span class="line">-RW-R--R-- 1 ROOT ROOT         0 2014-11-21 MONITOR_DISK.TXT</span><br><span class="line">DRWXR-XR-X 2 ROOT ROOT      4096 2014-11-21 SCRIPT</span><br><span class="line">-RW-R--R-- 1 ROOT ROOT        16 07-06 16:09 UPPERCASE.SH</span><br></pre></td></tr></table></figure>

<p>管道中的每个进程的stdout比下一个进程作为stdin来读入，否则，数据流会阻塞，并且管道将产生一些非预期的行为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从"cat file1 file2"中的输出并没出现</span></span><br><span class="line">cat file1 file2 | ls -l | sort</span><br></pre></td></tr></table></figure>

<p>作为子进程的运行的管道，不能够改变脚本的变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable=<span class="string">"initial_value"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"new_value"</span> | <span class="built_in">read</span> variable</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"variable = <span class="variable">$variable</span>"</span> <span class="comment"># variable =initial_value</span></span><br></pre></td></tr></table></figure>

<p>如果管道中的这个命令产生一个异常，并中途失败，那么这个管道将过早的终止，这种行为叫做broken pipe，并且这种状态下将发送一个<code>SIGPIPE</code>信号。</p>
<h2 id="gt"><a href="#gt" class="headerlink" title="&gt;|"></a><code>&gt;|</code></h2><p>强制重定向(使设置<code>noclobber</code>选项，就是<code>-C</code>选项)，这将强制的覆盖一个现存文件。</p>
<h2 id="-18"><a href="#-18" class="headerlink" title="||"></a><code>||</code></h2><p>或操作，在一个条件测试结构中，如果条件测试结构两边中的任意一边结果为true的话，<code>||</code>操作就会返回0(代表执行成功)。</p>
<h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a><code>&amp;</code></h2><p>后台运行命令，一个命令后边跟一个<code>&amp;</code>表示在后台运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 10 &amp;</span><br></pre></td></tr></table></figure>

<p>在一个脚本中，命令和循环都可能运行在后台：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in1 2 3 4 5 6 7 8 9 10</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$i</span> "</span></span><br><span class="line"><span class="keyword">done</span> &amp;</span><br></pre></td></tr></table></figure>

<p>在一个脚本中，使用后台运行命令可能会使这个脚本挂起，直到敲<code>ENTER</code> 键，挂起的脚本才会恢复。看起来只有在这个命令的结果需要输出到stdout的时候，这种现象才会出现。</p>
<p>只要在后台运行命令的后边加上一个<code>wait</code>命令就会解决这个问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"></span><br><span class="line">ls -l &amp;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Done."</span></span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure>

<p>如果将后台运行命令的输出重定向到文件中或<code>/dev/null</code>中，也能解决这个问题。</p>
<h2 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a><code>&amp;&amp;</code></h2><p>与逻辑操作。在一个条件测试结构中，只有在条件测试结构的两边结果都为true的时，<code>&amp;&amp;</code>操作才会返回0(代表sucess)。</p>
<h2 id="-19"><a href="#-19" class="headerlink" title="-"></a><code>-</code></h2><p>选项，前缀。在所有的命令内如果使用选项参数的话，前边都要加上<code>-</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br><span class="line"></span><br><span class="line">sort -dfu <span class="variable">$filename</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -- <span class="variable">$variable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$file1</span> -ot <span class="variable">$file2</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"File <span class="variable">$file1</span> is older than <span class="variable">$file2</span>."</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>用于重定向stdin或stdout：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从一个目录移动整个目录树到另一个目录</span></span><br><span class="line">(<span class="built_in">cd</span> /<span class="built_in">source</span>/directory &amp;&amp; tar cf - . ) | (<span class="built_in">cd</span> /dest/directory &amp;&amp; tar xpvf -)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然也可以这样写：</span></span><br><span class="line">cp -a /<span class="built_in">source</span>/directory/* /dest/directory</span><br><span class="line">cp -a /<span class="built_in">source</span>/directory/* /<span class="built_in">source</span>/directory/.[^.]* /dest/directory  <span class="comment"># 如果在/source/directory中有隐藏文件的话</span></span><br><span class="line"></span><br><span class="line">bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -</span><br></pre></td></tr></table></figure>

<p>注意，在这个上下文中，<code>-</code>本身并不是一个Bash操作，而是一个可以被特定的UNIX工具识别的选项，这些特定的UNIX工具特指那些可以写输出到stdout的工具，比如tar、cat等等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"whatever"</span> | cat -</span><br><span class="line">whatever</span><br></pre></td></tr></table></figure>

<p>使用diff命令来和另一个文件的一段进行比较：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep Linux file1 | diff file2 -</span><br></pre></td></tr></table></figure>

<p>一个更真实的例子是备份最后一天所有修改的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">BACKUPFILE=backup-$(date +%m-%d-%Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在命令行中没有指定备份文件的文件名，那么将默认使用"backup-MM-DD-YYYY.tar.gz"</span></span><br><span class="line">archive=<span class="variable">$&#123;1:-$BACKUPFILE&#125;</span></span><br><span class="line"></span><br><span class="line">tar cvf - `find . -mtime -1 -<span class="built_in">type</span> f -<span class="built_in">print</span>` &gt; <span class="variable">$archive</span>.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有两种简单写法：</span></span><br><span class="line"><span class="comment"># find . -mtime -1 -type f -print0 | xargs -0 tar rvf  "$archive.tar"</span></span><br><span class="line"><span class="comment"># find . -mtime -1 -type f -exec tar rvf "$archive.tar" '&#123;&#125;' \;</span></span><br><span class="line"></span><br><span class="line">gzip <span class="variable">$archive</span>.tar</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Directory <span class="variable">$PWD</span> backed up in archive file \"<span class="variable">$archive</span>.tar.gz\"."</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p><code>-</code>还可以用来指先前的工作目录，<code>cd -</code>将会回到当前的工作目录，它使用了 <code>$OLDPWD</code> 环境变量。</p>
<p>另外，还可以当做减号来使用。</p>
<h2 id="-20"><a href="#-20" class="headerlink" title="="></a><code>=</code></h2><p>等号，赋值操作。</p>
<h2 id="-21"><a href="#-21" class="headerlink" title="+"></a><code>+</code></h2><p>加号，也可以用在正则表达式中。某些内建命令使用<code>+</code>来打开特定的选项，用<code>-</code>来用这些特定的选项。</p>
<h2 id="-22"><a href="#-22" class="headerlink" title="%"></a><code>%</code></h2><p>取模操作，也可以用于正则表达式。</p>
<h2 id="-23"><a href="#-23" class="headerlink" title="~"></a><code>~</code></h2><p>home目录。</p>
<h2 id="-24"><a href="#-24" class="headerlink" title="~+"></a><code>~+</code></h2><p>当前工作目录，相当于<code>$PWD</code>内部变量。</p>
<h2 id="-25"><a href="#-25" class="headerlink" title="~-"></a><code>~-</code></h2><p>当前的工作目录，相当于<code>$OLDPWD</code>内部变量。</p>
<h2 id="-26"><a href="#-26" class="headerlink" title="^"></a><code>^</code></h2><p>行首，在正则表达式中，<code>^</code>表示定位到文本行的行首。</p>
<h2 id="控制字符"><a href="#控制字符" class="headerlink" title="控制字符"></a>控制字符</h2><p>修改终端或文本显示的行为。控制字符以<code>CONTROL + key</code>这种方式进行组合(同时按下)。控制字符也可以使用8进制或16进制表示法来进行表示，但是前边必须要加上转义符。</p>
<p>控制字符比较多，这里不一一列出了。</p>
<h2 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h2><p>用来分隔函数，命令或变量。空白包含空格、tab、空行，或者是它们之间任意的组合体。在某些上下文中，比如变量赋值，空白是不被允许的，会产生语法错误。</p>
<p>空行不会影响脚本的行为，因此使用空行可以很好的划分独立的函数段以增加可读性。</p>
<p>特殊变量<code>$IFS</code>用来做一些输入命令的分隔符，默认情况下是空白。</p>
<p>如果想在字符串或变量中使用空白，那么应该使用引用。例如下面例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello=<span class="string">"A B  C   D"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$hello</span>                  <span class="comment"># A B C D</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$hello</span>"</span>               <span class="comment"># A B  C   D</span></span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.javachen.com/static/doc/abs-guide/html/index.html">高级Bash脚本编程指南-中文版</a></li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="JavaChen 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="JavaChen 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    JavaChen
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://blog.javachen.com/2015/07/06/bash-special-characters/" title="Bash中的特殊字符">http://blog.javachen.com/2015/07/06/bash-special-characters/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/bash/" rel="tag"># bash</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/06/30/jekyll-kramdown-config/" rel="next" title="Jekyll kramdown配置">
                <i class="fa fa-chevron-left"></i> Jekyll kramdown配置
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/07/07/bash-variable/" rel="prev" title="Bash中的变量">
                Bash中的变量 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2009 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-post-description"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JavaChen</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
